{"version":3,"names":["iconContent","Map","requests","getSvgContent","url","request","get","fetch","then","response","ok","text","svgContent","set","iconCss","ChIconStyle0","ChIcon","io","connectedCallback","this","waitUntilVisible","element","isVisible","getIcon","disconnectedCallback","undefined","disconnect","el","rootMargin","callback","lazy","window","IntersectionObserver","data","isIntersecting","observe","src","has","render","h","key","innerHTML"],"sources":["src/deprecated-components/icon/requests.ts","src/deprecated-components/icon/icon.scss?tag=ch-icon&encapsulation=shadow","src/deprecated-components/icon/icon.tsx"],"sourcesContent":["export const iconContent = new Map<string, string>();\r\nconst requests = new Map<string, Promise<any>>();\r\n\r\nexport function getSvgContent(url: string) {\r\n  // see if we already have a request for this url\r\n  let request = requests.get(url);\r\n\r\n  if (!request) {\r\n    // we don't already have a request\r\n    // @ts-expect-error: This implementation is deprecated, so we are avoiding this error\r\n    request = fetch(url).then(response => {\r\n      if (response.ok) {\r\n        return response.text().then(svgContent => {\r\n          iconContent.set(url, svgContent);\r\n          return svgContent;\r\n        });\r\n      }\r\n      iconContent.set(url, \"\");\r\n    });\r\n\r\n    // cache for the same requests\r\n    requests.set(url, request);\r\n  }\r\n\r\n  return request;\r\n}\r\n",":host(:not([auto-color])) {\r\n  /**\r\n  * @prop --icon-color: Color of the icon (sets the SVG's `fill` property)\r\n  */\r\n  svg {\r\n    * {\r\n      fill: var(--icon-color) !important;\r\n    }\r\n  }\r\n\r\n  //Composed icons colors\r\n  path.icons01 {\r\n    fill: var(--icons01-enabled);\r\n  }\r\n  path.icons02 {\r\n    fill: var(--icons02-enabled);\r\n  }\r\n  path.icons03 {\r\n    fill: var(--icons03-enabled);\r\n  }\r\n  path.icons04 {\r\n    fill: var(--icons04-enabled);\r\n  }\r\n  path.icons05 {\r\n    fill: var(--icons05-enabled);\r\n  }\r\n  path.icons06 {\r\n    fill: var(--icons06-enabled);\r\n  }\r\n  path.icons07 {\r\n    fill: var(--icons07-enabled);\r\n  }\r\n  path.icons08 {\r\n    fill: var(--icons08-enabled);\r\n  }\r\n  path.icons09 {\r\n    fill: var(--icons09-enabled);\r\n  }\r\n}\r\n:host {\r\n  /**\r\n  * @prop --icon-size: Size of the icon (sets both width and height)\r\n  */\r\n  display: inline-flex;\r\n  svg {\r\n    width: var(--icon-size);\r\n    height: var(--icon-size);\r\n  }\r\n  line-height: 0;\r\n}\r\n","import { Component, Element, Prop, State, Watch, h } from \"@stencil/core\";\r\nimport { getSvgContent, iconContent } from \"./requests\";\r\n\r\n@Component({\r\n  tag: \"ch-icon\",\r\n  styleUrl: \"icon.scss\",\r\n  shadow: true,\r\n  assetsDirs: [\"ch-icon-assets\"]\r\n})\r\nexport class ChIcon {\r\n  private io?: IntersectionObserver;\r\n\r\n  @Element() element: HTMLChIconElement;\r\n\r\n  /** *******************************\r\n  PROPERTIES & STATE\r\n  *********************************/\r\n  /**\r\n   * The color of the icon.\r\n   *\r\n   */\r\n  @Prop() readonly color: Color;\r\n  /**\r\n   * If enabled, the icon will be loaded lazily when it's visible in the viewport.\r\n   */\r\n  @Prop() readonly lazy: boolean = false;\r\n\r\n  /**\r\n   * If enabled, the icon will display its inherent/natural color\r\n   */\r\n  @Prop({ reflect: true }) readonly autoColor: boolean = false;\r\n\r\n  /**\r\n   * The URL of the icon.\r\n   */\r\n  @Prop({ reflect: true }) readonly src: string = \"\";\r\n\r\n  /**\r\n   * The size of the icon. Possible values: regular, small.\r\n   */\r\n  @Prop() readonly size: Size = \"regular\";\r\n\r\n  @State() private isVisible = false;\r\n\r\n  @State() private svgContent?: string;\r\n\r\n  /** *******************************\r\n  METHODS\r\n  *********************************/\r\n\r\n  connectedCallback() {\r\n    // purposely do not return the promise here because loading\r\n    // the svg file should not hold up loading the app\r\n    // only load the svg if it's visible\r\n    this.waitUntilVisible(this.element, \"50px\", () => {\r\n      this.isVisible = true;\r\n      this.getIcon();\r\n    });\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (this.io !== undefined) {\r\n      this.io.disconnect();\r\n      this.io = undefined;\r\n    }\r\n  }\r\n\r\n  private waitUntilVisible(\r\n    el: HTMLElement,\r\n    rootMargin: string,\r\n    callback: () => void\r\n  ) {\r\n    if (\r\n      this.lazy &&\r\n      typeof window !== \"undefined\" &&\r\n      (window as any).IntersectionObserver\r\n    ) {\r\n      // TODO: FIX THIS\r\n      // eslint-disable-next-line no-multi-assign\r\n      const io = (this.io = new (window as any).IntersectionObserver(\r\n        (data: IntersectionObserverEntry[]) => {\r\n          if (data[0].isIntersecting) {\r\n            io.disconnect();\r\n            this.io = undefined;\r\n            callback();\r\n          }\r\n        },\r\n        { rootMargin }\r\n      ));\r\n\r\n      io.observe(el);\r\n    } else {\r\n      // browser doesn't support IntersectionObserver\r\n      // so just fallback to always show it\r\n      callback();\r\n    }\r\n  }\r\n\r\n  @Watch(\"src\")\r\n  private async getIcon() {\r\n    if (this.isVisible) {\r\n      if (this.src) {\r\n        if (iconContent.has(this.src)) {\r\n          this.svgContent = iconContent.get(this.src);\r\n        } else {\r\n          this.svgContent = await getSvgContent(this.src);\r\n        }\r\n      } else {\r\n        this.svgContent = \"\";\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return <div innerHTML={this.svgContent} />;\r\n  }\r\n}\r\n\r\nexport type Color =\r\n  | \"primary-enabled\"\r\n  | \"primary-active\"\r\n  | \"primary-hover\"\r\n  | \"onbackground\"\r\n  | \"negative\"\r\n  | \"disabled\"\r\n  | \"ondisabled\"\r\n  | \"error\"\r\n  | \"success\"\r\n  | \"warning\"\r\n  | \"alwaysblack\"\r\n  | \"auto\";\r\n\r\nexport type Size = \"regular\" | \"small\";\r\n"],"mappings":"kDAAO,MAAMA,EAAc,IAAIC,IAC/B,MAAMC,EAAW,IAAID,I,SAELE,EAAcC,GAE5B,IAAIC,EAAUH,EAASI,IAAIF,GAE3B,IAAKC,EAAS,CAGZA,EAAUE,MAAMH,GAAKI,MAAKC,IACxB,GAAIA,EAASC,GAAI,CACf,OAAOD,EAASE,OAAOH,MAAKI,IAC1BZ,EAAYa,IAAIT,EAAKQ,GACrB,OAAOA,CAAU,G,CAGrBZ,EAAYa,IAAIT,EAAK,GAAG,IAI1BF,EAASW,IAAIT,EAAKC,E,CAGpB,OAAOA,CACT,CCzBA,MAAMS,EAAU,uzBAChB,MAAAC,EAAeD,E,MCQFE,EAAM,M,wDAgBgB,M,eAKsB,M,SAKP,G,UAKlB,U,eAED,M,0BAhCrBC,G,6BAwCR,iBAAAC,GAIEC,KAAKC,iBAAiBD,KAAKE,QAAS,QAAQ,KAC1CF,KAAKG,UAAY,KACjBH,KAAKI,SAAS,G,CAIlB,oBAAAC,GACE,GAAIL,KAAKF,KAAOQ,UAAW,CACzBN,KAAKF,GAAGS,aACRP,KAAKF,GAAKQ,S,EAIN,gBAAAL,CACNO,EACAC,EACAC,GAEA,GACEV,KAAKW,aACEC,SAAW,aACjBA,OAAeC,qBAChB,CAGA,MAAMf,EAAME,KAAKF,GAAK,IAAKc,OAAeC,sBACvCC,IACC,GAAIA,EAAK,GAAGC,eAAgB,CAC1BjB,EAAGS,aACHP,KAAKF,GAAKQ,UACVI,G,IAGJ,CAAED,eAGJX,EAAGkB,QAAQR,E,KACN,CAGLE,G,EAKI,aAAMN,GACZ,GAAIJ,KAAKG,UAAW,CAClB,GAAIH,KAAKiB,IAAK,CACZ,GAAIpC,EAAYqC,IAAIlB,KAAKiB,KAAM,CAC7BjB,KAAKP,WAAaZ,EAAYM,IAAIa,KAAKiB,I,KAClC,CACLjB,KAAKP,iBAAmBT,EAAcgB,KAAKiB,I,MAExC,CACLjB,KAAKP,WAAa,E,GAKxB,MAAA0B,GACE,OAAOC,EAAA,OAAAC,IAAA,2CAAKC,UAAWtB,KAAKP,Y"}