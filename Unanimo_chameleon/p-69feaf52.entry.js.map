{"version":3,"names":["makeLinesClampable","component","contentElementSelector","contentContainerElementSelector","lineMeasuringElementSelector","componentHasShadowDOM","lineClamp","contentElement","contentContainerElement","lineMeasuringElement","contentHeight","contentContainerHeight","lineMeasuringHeight","applyLineClamp","debounce","requestAnimationFrame","currentContentContainerHeight","clientHeight","currentContentHeight","scrollHeight","currentLineMeasuringHeight","contentLines","Math","max","trunc","maxLines","resizeObserverContainer","overrideMethod","before","componentElement","element","shadowRoot","querySelector","ResizeObserver","observe","disconnect","undefined","textblockCss","ChTextblockStyle0","TextBlock","constructor","hostRef","this","LINE_CLAMP","HEIGHT_MEASURING","LINE_MEASURING","getTooltip","noNeedToDisplayTooltip","tooltip","tooltipShowMode","render","justRenderTheSlot","format","h","Host","key","role","title","class","part","style","toString"],"sources":["src/common/line-clamp.ts","src/components/textblock/textblock.scss?tag=ch-textblock&encapsulation=shadow","src/components/textblock/textblock.tsx"],"sourcesContent":["import { debounce, overrideMethod } from \"./utils\";\r\nimport { Component } from \"./interfaces\";\r\n\r\nexport function makeLinesClampable(\r\n  component: LineClampComponent,\r\n  contentElementSelector: string,\r\n  contentContainerElementSelector: string,\r\n  lineMeasuringElementSelector: string,\r\n  componentHasShadowDOM = false\r\n): void | { applyLineClamp: () => void } {\r\n  if (!component.lineClamp) {\r\n    return;\r\n  }\r\n\r\n  // Used to know the sizes of the `content`\r\n  let contentElement: HTMLElement;\r\n\r\n  // Used to know the sizes of the `content-container`\r\n  let contentContainerElement: HTMLElement;\r\n\r\n  // Used to measure the line height\r\n  let lineMeasuringElement: HTMLElement;\r\n\r\n  // Used to keep the state of the component\r\n  let contentHeight = -1;\r\n  let contentContainerHeight = -1;\r\n  let lineMeasuringHeight = -1;\r\n\r\n  const applyLineClamp = debounce(() => {\r\n    requestAnimationFrame(() => {\r\n      const currentContentContainerHeight =\r\n        contentContainerElement.clientHeight;\r\n\r\n      if (currentContentContainerHeight === 0) {\r\n        return;\r\n      }\r\n\r\n      const currentContentHeight = contentElement.scrollHeight;\r\n      const currentLineMeasuringHeight = lineMeasuringElement.clientHeight;\r\n\r\n      /*  If the container height and the line height have not been changed,\r\n          there is not need to update `component.maxLines`\r\n      */\r\n      if (\r\n        contentHeight === currentContentHeight &&\r\n        contentContainerHeight === currentContentContainerHeight &&\r\n        lineMeasuringHeight === currentLineMeasuringHeight\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      // Stores the current height of the content container and line measurement\r\n      contentHeight = currentContentHeight;\r\n      contentContainerHeight = currentContentContainerHeight;\r\n      lineMeasuringHeight = currentLineMeasuringHeight;\r\n\r\n      // Set how much lines needs the control to not overflow its content\r\n      component.contentLines = Math.max(\r\n        Math.trunc(currentContentHeight / lineMeasuringHeight),\r\n        1\r\n      );\r\n\r\n      // At least, one line will be displayed\r\n      component.maxLines = Math.max(\r\n        Math.trunc(currentContentContainerHeight / lineMeasuringHeight),\r\n        1\r\n      );\r\n    });\r\n  }, 10);\r\n\r\n  let resizeObserverContainer: ResizeObserver = null;\r\n\r\n  overrideMethod(component, \"componentDidLoad\", {\r\n    before: () => {\r\n      const componentElement = component.element;\r\n\r\n      if (componentHasShadowDOM) {\r\n        contentElement = componentElement.shadowRoot.querySelector(\r\n          contentElementSelector\r\n        ) as HTMLElement;\r\n\r\n        contentContainerElement = componentElement.shadowRoot.querySelector(\r\n          contentContainerElementSelector\r\n        ) as HTMLElement;\r\n\r\n        lineMeasuringElement = componentElement.shadowRoot.querySelector(\r\n          lineMeasuringElementSelector\r\n        ) as HTMLElement;\r\n      } else {\r\n        contentElement = componentElement.querySelector(\r\n          contentElementSelector\r\n        ) as HTMLElement;\r\n\r\n        contentContainerElement = componentElement.querySelector(\r\n          contentContainerElementSelector\r\n        ) as HTMLElement;\r\n\r\n        lineMeasuringElement = componentElement.querySelector(\r\n          lineMeasuringElementSelector\r\n        ) as HTMLElement;\r\n      }\r\n\r\n      if (contentContainerElement === null || lineMeasuringElement === null) {\r\n        return;\r\n      }\r\n\r\n      /*  If the `content-container` resizes or the `font-size` changes, it\r\n            checks if it is necessary to update `component.maxLines`\r\n        */\r\n      resizeObserverContainer = new ResizeObserver(() => {\r\n        applyLineClamp();\r\n      });\r\n\r\n      // Observe the content, content-container and line height\r\n      resizeObserverContainer.observe(contentElement);\r\n      resizeObserverContainer.observe(contentContainerElement);\r\n      resizeObserverContainer.observe(lineMeasuringElement);\r\n    }\r\n  });\r\n\r\n  overrideMethod(component, \"disconnectedCallback\", {\r\n    before: () => {\r\n      if (resizeObserverContainer) {\r\n        resizeObserverContainer.disconnect();\r\n        resizeObserverContainer = undefined;\r\n      }\r\n    }\r\n  });\r\n\r\n  return {\r\n    applyLineClamp\r\n  };\r\n}\r\n\r\nexport interface LineClampComponent extends Component {\r\n  lineClamp: boolean;\r\n  contentLines: number;\r\n  maxLines: number;\r\n}\r\n","@import \"../../common/_base\";\r\n\r\n@include box-sizing();\r\n@include line-clamp();\r\n\r\n:host {\r\n  display: flex;\r\n  align-items: flex-start;\r\n  justify-items: flex-start;\r\n  align-self: stretch;\r\n  position: relative;\r\n  width: 100%;\r\n  text-align: start; // Default alignment which supports RTL\r\n}\r\n\r\n// - - - - - - - - - - - - - - - - - - - -\r\n//      Format = \"Text\" and lineClamp\r\n// - - - - - - - - - - - - - - - - - - - -\r\n.content {\r\n  @include reset-browser-defaults-properties-1();\r\n\r\n  position: absolute;\r\n  inset-inline: 0;\r\n  padding-inline: inherit;\r\n}\r\n","import { Component, Element, Host, Prop, State, h } from \"@stencil/core\";\r\n\r\nimport {\r\n  LineClampComponent,\r\n  makeLinesClampable\r\n} from \"../../common/line-clamp\";\r\n\r\nimport {\r\n  HEIGHT_MEASURING,\r\n  LINE_CLAMP,\r\n  LINE_MEASURING\r\n} from \"../../common/reserverd-names\";\r\n\r\n/**\r\n * @part content - The main content displayed in the control. This part only applies when `format=\"Text\"` and lineClamp=\"true\".\r\n *\r\n * @slot - The slot for the content.\r\n */\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"textblock.scss\",\r\n  tag: \"ch-textblock\"\r\n})\r\nexport class TextBlock implements LineClampComponent {\r\n  constructor() {\r\n    makeLinesClampable(\r\n      this,\r\n      \".\" + LINE_CLAMP,\r\n      \".\" + HEIGHT_MEASURING,\r\n      \".\" + LINE_MEASURING,\r\n      true\r\n    );\r\n  }\r\n\r\n  @Element() element: HTMLChTextblockElement;\r\n\r\n  @State() contentLines = 0;\r\n  @State() maxLines = 0;\r\n\r\n  /**\r\n   * It specifies the format that will have the textblock control.\r\n   *\r\n   *  - If `format` = `HTML`, the textblock control works as an HTML div and\r\n   *    the innerHTML will be taken from the default slot.\r\n   *\r\n   *  - If `format` = `Text`, the control works as a normal textblock control\r\n   *    and it is affected by most of the defined properties.\r\n   */\r\n  @Prop() readonly format: \"Text\" | \"HTML\" = \"Text\";\r\n\r\n  /**\r\n   * True to cut text when it overflows, showing an ellipsis.\r\n   */\r\n  @Prop() readonly lineClamp: boolean = false;\r\n\r\n  /**\r\n   * Determine the tooltip text that will be displayed when the pointer is over\r\n   * the control\r\n   */\r\n  @Prop() readonly tooltip: string;\r\n\r\n  /**\r\n   * Determine the way that the tooltip text will be displayed\r\n   */\r\n  @Prop() readonly tooltipShowMode: \"always\" | \"line-clamp\" = \"always\";\r\n\r\n  private getTooltip() {\r\n    const noNeedToDisplayTooltip =\r\n      !this.tooltip ||\r\n      (this.tooltipShowMode === \"line-clamp\" &&\r\n        this.lineClamp &&\r\n        this.contentLines <= this.maxLines);\r\n\r\n    return noNeedToDisplayTooltip ? null : this.tooltip;\r\n  }\r\n\r\n  render() {\r\n    const justRenderTheSlot = this.format === \"HTML\" || !this.lineClamp;\r\n\r\n    return (\r\n      <Host\r\n        role={this.format === \"Text\" && !this.lineClamp ? \"paragraph\" : null}\r\n        title={this.getTooltip()}\r\n      >\r\n        {justRenderTheSlot ? (\r\n          <slot />\r\n        ) : (\r\n          [\r\n            <div class={LINE_MEASURING}>A</div>,\r\n            <div class={HEIGHT_MEASURING}></div>,\r\n            <p\r\n              class={`content ${LINE_CLAMP}`}\r\n              part=\"content\"\r\n              style={{ \"--max-lines\": this.maxLines.toString() }}\r\n            >\r\n              <slot />\r\n            </p>\r\n          ]\r\n        )}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"+JAGgBA,EACdC,EACAC,EACAC,EACAC,EACAC,EAAwB,OAExB,IAAKJ,EAAUK,UAAW,CACxB,M,CAIF,IAAIC,EAGJ,IAAIC,EAGJ,IAAIC,EAGJ,IAAIC,GAAiB,EACrB,IAAIC,GAA0B,EAC9B,IAAIC,GAAuB,EAE3B,MAAMC,EAAiBC,GAAS,KAC9BC,uBAAsB,KACpB,MAAMC,EACJR,EAAwBS,aAE1B,GAAID,IAAkC,EAAG,CACvC,M,CAGF,MAAME,EAAuBX,EAAeY,aAC5C,MAAMC,EAA6BX,EAAqBQ,aAKxD,GACEP,IAAkBQ,GAClBP,IAA2BK,GAC3BJ,IAAwBQ,EACxB,CACA,M,CAIFV,EAAgBQ,EAChBP,EAAyBK,EACzBJ,EAAsBQ,EAGtBnB,EAAUoB,aAAeC,KAAKC,IAC5BD,KAAKE,MAAMN,EAAuBN,GAClC,GAIFX,EAAUwB,SAAWH,KAAKC,IACxBD,KAAKE,MAAMR,EAAgCJ,GAC3C,EACD,GACD,GACD,IAEH,IAAIc,EAA0C,KAE9CC,EAAe1B,EAAW,mBAAoB,CAC5C2B,OAAQ,KACN,MAAMC,EAAmB5B,EAAU6B,QAEnC,GAAIzB,EAAuB,CACzBE,EAAiBsB,EAAiBE,WAAWC,cAC3C9B,GAGFM,EAA0BqB,EAAiBE,WAAWC,cACpD7B,GAGFM,EAAuBoB,EAAiBE,WAAWC,cACjD5B,E,KAEG,CACLG,EAAiBsB,EAAiBG,cAChC9B,GAGFM,EAA0BqB,EAAiBG,cACzC7B,GAGFM,EAAuBoB,EAAiBG,cACtC5B,E,CAIJ,GAAII,IAA4B,MAAQC,IAAyB,KAAM,CACrE,M,CAMFiB,EAA0B,IAAIO,gBAAe,KAC3CpB,GAAgB,IAIlBa,EAAwBQ,QAAQ3B,GAChCmB,EAAwBQ,QAAQ1B,GAChCkB,EAAwBQ,QAAQzB,EAAqB,IAIzDkB,EAAe1B,EAAW,uBAAwB,CAChD2B,OAAQ,KACN,GAAIF,EAAyB,CAC3BA,EAAwBS,aACxBT,EAA0BU,S,KAKhC,MAAO,CACLvB,iBAEJ,CCpIA,MAAMwB,EAAe,4qBACrB,MAAAC,EAAeD,E,MCsBFE,EAAS,MACpB,WAAAC,CAAAC,G,4BAYwB,E,cACJ,E,YAWuB,O,eAKL,M,4CAWsB,SAvC1DzC,EACE0C,KACA,IAAMC,EACN,IAAMC,EACN,IAAMC,EACN,K,8BAoCI,UAAAC,GACN,MAAMC,GACHL,KAAKM,SACLN,KAAKO,kBAAoB,cACxBP,KAAKpC,WACLoC,KAAKrB,cAAgBqB,KAAKjB,SAE9B,OAAOsB,EAAyB,KAAOL,KAAKM,O,CAG9C,MAAAE,GACE,MAAMC,EAAoBT,KAAKU,SAAW,SAAWV,KAAKpC,UAE1D,OACE+C,EAACC,EAAI,CAAAC,IAAA,2CACHC,KAAMd,KAAKU,SAAW,SAAWV,KAAKpC,UAAY,YAAc,KAChEmD,MAAOf,KAAKI,cAEXK,EACCE,EAAA,aAAQ,CAGNA,EAAA,OAAKK,MAAOb,GAAc,KAC1BQ,EAAA,OAAKK,MAAOd,IACZS,EAAA,KACEK,MAAO,WAAWf,IAClBgB,KAAK,UACLC,MAAO,CAAE,cAAelB,KAAKjB,SAASoC,aAEtCR,EAAA,e"}