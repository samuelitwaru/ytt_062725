{"version":3,"names":["listCss","ChListStyle0","TRANSITION_DURATION","BUTTON_POSITION_X","BUTTON_POSITION_Y","BUTTON_SIZE","MOUSE_OFFSET_X","MOUSE_OFFSET_Y","MOUSE_POSITION_X","MOUSE_POSITION_Y","TAB_LIST_EDGE_START_POSITION","TAB_LIST_EDGE_END_POSITION","DECORATIVE_IMAGE","ARROW_UP","ARROW_RIGHT","ARROW_DOWN","ARROW_LEFT","HOME","END","FIRST_CAPTION_BUTTON","tabListRef","querySelector","LAST_CAPTION_BUTTON","isBlockDirection","direction","setProperty","element","property","value","style","setButtonInitialPosition","positionX","positionY","setButtonSize","size","setMousePosition","setTabListStartEndPosition","startPosition","endPosition","getTabListSizesAndSetPosition","hostRef","buttonRect","tabListRect","getBoundingClientRect","tabListSizes","xStart","x","xEnd","width","yStart","y","yEnd","height","setMouseOffset","offsetX","offsetY","addGrabbingStyle","document","body","removeGrabbingStyle","removeProperty","focusNextOrPreviousCaption","focusNextSibling","focusedCaption","event","preventDefault","nextFocusedCaption","nextElementSibling","previousElementSibling","focus","click","ChList","cancelId","classes","parts","selectedIndex","lastDragEvent","needForRAF","initialMousePosition","itemSizes","mouseBoundingLimits","renderedPages","Set","dragPreviewRef","tabPageRef","keyEvents","ev","focusedButton","this","isRTL","directionChange","newDirection","initializeState","modelChanged","newModel","updateRenderedPages","handleSelectedIdChange","newSelectedId","add","expandMainGroup","itemClose","selectedItemChange","itemDragStart","endDragPreview","handleDragEnd","getDraggableViews","mainView","el","pageView","tabListView","promoteDragPreviewToTopLayer","draggedElementIndex","popover","showPopover","removePage","pageId","forceRerender","delete","forceUpdate","handleSelectedItemChange","index","itemId","stopPropagation","eventInfo","emit","lastSelectedIndex","newSelectedIndex","defaultPrevented","selectedId","items","forEach","item","wasRendered","id","handleDragStart","mousePositionX","clientX","mousePositionY","clientY","getItemSize","children","map","target","buttonSizes","mouseDistanceToButtonTopEdge","mouseDistanceToButtonBottomEdge","mouseDistanceToButtonLeftEdge","mouseDistanceToButtonRightEdge","dragOutsideDisabled","addEventListener","handleItemDrag","capture","passive","cancelAnimationFrame","removeEventListener","anItemWasReordered","hasCrossedBoundaries","draggedElementNewIndex","itemToInsert","removeElement","model","insertIntoIndex","adjustLastSelectedIndexValueAfterReorder","undefined","requestAnimationFrame","mouseLimits","draggedButtonIsInsideTheTabList","inBetween","length","mousePosition","hasMovedToTheEnd","distanceTraveled","Math","abs","newIndex","handleClose","itemIndex","handleTabFocus","keyEventHandler","code","currentFocusedCaption","focusComposedPath","closest","BUTTON","imgRender","startImageType","startImageSrc","h","class","IMAGE","part","alt","src","loading","renderTabBar","thereAreShiftedElements","role","accessibleName","TAB_LIST","ref","onKeyDown","key","CAPTION_ID","PAGE_ID","showCaptions","name","toString","isPseudoElementImg","sortable","tokenMap","SELECTED_PART","onAuxClick","onClick","onDragStart","closeButtonHidden","closeButtonAccessibleName","CLOSE_BUTTON_PART","type","renderTabPages","PAGE_CONTAINER","expanded","keys","PAGE","renderDragPreview","draggedElement","DRAG_PREVIEW","DRAG_PREVIEW_OUTSIDE","DRAG_PREVIEW_INSIDE_INLINE","DRAG_PREVIEW_INSIDE_BLOCK","decorativeImage","DRAG_PREVIEW_ELEMENT","setClassesAndParts","LIST_CLASSES","LIST_PART_BLOCK","LIST_PART_INLINE","componentWillLoad","render","draggedIndex","thereAreShiftedElementsInPreview","Host"],"sources":["src/components/list/list.scss?tag=ch-list&encapsulation=shadow","src/components/list/list.tsx"],"sourcesContent":["@import \"../../common/_base\";\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//         Caption button\r\n// - - - - - - - - - - - - - - - -\r\n:where(button) {\r\n  all: unset;\r\n  display: flex;\r\n  align-items: center;\r\n\r\n  // Disallow selecting the text\r\n  user-select: none;\r\n\r\n  // Avoid zooming on double tap on iOS devices\r\n  touch-action: manipulation;\r\n\r\n  cursor: pointer;\r\n}\r\n\r\n@include box-sizing();\r\n\r\n$z-index-gx-navbar-item: 107; // Same as $z-index-gx-navbar-item from w-c-l\r\n\r\n:host {\r\n  --ch-list-transition-duration: 150ms;\r\n  --ch-list-mask-image-size: 100%;\r\n  --ch-list-image-size: 18px;\r\n\r\n  display: grid;\r\n  block-size: 100%;\r\n}\r\n\r\n// :host([type=\"blockStart\"]) {\r\n//   grid-auto-flow: row;\r\n//   grid-auto-rows: max-content;\r\n// }\r\n\r\n:host(.ch-list-direction--block) {\r\n  grid-template-rows: max-content 1fr;\r\n}\r\n\r\n:host(.ch-list-direction--inline) {\r\n  grid-template-columns: max-content 1fr;\r\n}\r\n\r\n.sortable {\r\n  // Allow user drag\r\n  -webkit-user-drag: element;\r\n}\r\n\r\n.caption-image,\r\n.decorative-image::before {\r\n  display: block;\r\n  block-size: var(--ch-list-image-size);\r\n  inline-size: var(--ch-list-image-size);\r\n}\r\n\r\n.decorative-image::before {\r\n  content: \"\";\r\n  -webkit-mask: var(--ch-list-decorative-image) 50% 50% /\r\n    var(--ch-list-mask-image-size) var(--ch-list-mask-image-size) no-repeat;\r\n  background-color: currentColor;\r\n}\r\n\r\n.close-button {\r\n  &::after {\r\n    content: \"\";\r\n    display: flex;\r\n    block-size: 1em;\r\n    inline-size: 1em;\r\n    -webkit-mask: url('data:image/svg+xml,<svg width=\"18\" height=\"18\" viewBox=\"0 0 18 18\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 2L15.5 15.5\" stroke=\"white\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/><path d=\"M15.5 2L2 15.5\" stroke=\"white\" stroke-width=\"1.2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>')\r\n      50% 50% / 0.75em 0.75em no-repeat;\r\n    background-color: currentColor;\r\n    opacity: 0;\r\n  }\r\n}\r\n\r\n.button {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n\r\n  &:hover > .close-button::after,\r\n  &:focus-within > .close-button::after,\r\n  &[aria-selected=\"true\"] > .close-button::after {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//          Drag preview\r\n// - - - - - - - - - - - - - - - -\r\n// \"Hide\" the dragged element, without removing it from the accessibility tree\r\n.dragged-element {\r\n  opacity: 0;\r\n\r\n  &--outside {\r\n    display: none;\r\n  }\r\n}\r\n\r\n.drag-preview {\r\n  // \"clamp\" implements snap to the edges\r\n  --ch-list-snap-drag-preview: clamp(\r\n    var(--ch-list-tab-list-start),\r\n    var(--ch-list-mouse-position),\r\n    var(--ch-list-tab-list-end)\r\n  );\r\n\r\n  position: fixed;\r\n  left: 0; // Necessary since the custom vars are physical values\r\n  top: 0; // Necessary since the custom vars are physical values\r\n  z-index: $z-index-gx-navbar-item + 1;\r\n\r\n  &:popover-open {\r\n    // Reset popover's browser defaults\r\n    padding: 0;\r\n    margin: 0;\r\n    border: unset;\r\n    color: unset;\r\n\r\n    // Native popovers have \"inset: 0\", so we need to reset that property with\r\n    // the physical values again to support RTL\r\n    inset: unset;\r\n    left: 0;\r\n    top: 0;\r\n\r\n    // The preview MUST NOT capture pointer-events in order to properly show\r\n    // the droppable areas\r\n    pointer-events: none;\r\n  }\r\n\r\n  &-element {\r\n    cursor: grabbing;\r\n  }\r\n\r\n  // Drag outside\r\n  &--outside-tab-list {\r\n    transform: translate(\r\n      calc(var(--ch-list-mouse-position-x) - var(--ch-list-mouse-offset-x)),\r\n      calc(var(--ch-list-mouse-position-y) - var(--ch-list-mouse-offset-y))\r\n    );\r\n  }\r\n\r\n  // Drag inside (block)\r\n  &--inside-tab-list__block {\r\n    --ch-list-mouse-position: calc(\r\n      var(--ch-list-mouse-position-x) - var(--ch-list-mouse-offset-x)\r\n    );\r\n\r\n    transform: translate(\r\n      var(--ch-list-snap-drag-preview),\r\n      var(--ch-list-button-position-y)\r\n    );\r\n  }\r\n\r\n  // Drag inside (inline)\r\n  &--inside-tab-list__inline {\r\n    --ch-list-mouse-position: calc(\r\n      var(--ch-list-mouse-position-y) - var(--ch-list-mouse-offset-y)\r\n    );\r\n\r\n    transform: translate(\r\n      var(--ch-list-button-position-x),\r\n      var(--ch-list-snap-drag-preview)\r\n    );\r\n  }\r\n}\r\n\r\n.shifted-element {\r\n  transition: transform var(--ch-list-transition-duration);\r\n}\r\n\r\n:host(.ch-list-direction--block) {\r\n  .shifted-element--start {\r\n    transform: translate(calc(var(--ch-list-button-size) * -1), 0);\r\n  }\r\n\r\n  .shifted-element--end {\r\n    transform: translate(var(--ch-list-button-size), 0);\r\n  }\r\n}\r\n\r\n:host(.ch-list-direction--inline) {\r\n  .shifted-element--start {\r\n    transform: translateY(calc(var(--ch-list-button-size) * -1));\r\n  }\r\n\r\n  .shifted-element--end {\r\n    transform: translateY(var(--ch-list-button-size));\r\n  }\r\n}\r\n\r\n// - - - - - - - - - - - - - - - -\r\n//            Tab lists\r\n// - - - - - - - - - - - - - - - -\r\n:host([direction=\"inline\"]) > .tab-list {\r\n  display: grid;\r\n  grid-auto-flow: row;\r\n  grid-auto-rows: max-content;\r\n}\r\n\r\n:host([direction=\"block\"]) > .tab-list {\r\n  display: grid;\r\n  grid-auto-flow: column;\r\n  grid-auto-columns: max-content;\r\n}\r\n\r\n.page {\r\n  contain: strict;\r\n  display: grid;\r\n}\r\n\r\n.page-container {\r\n  display: grid;\r\n  grid-template: \"selected\" 1fr / 1fr;\r\n  block-size: 100%;\r\n  inline-size: 100%;\r\n}\r\n\r\n.page--selected {\r\n  grid-area: selected;\r\n}\r\n\r\n// content-visibility: hidden is faster for rendering the content back, as\r\n// it preserves the rendering state of the content (display: none does not)\r\n@supports (content-visibility: hidden) {\r\n  .page-container--collapsed,\r\n  .page--hidden {\r\n    content-visibility: hidden;\r\n  }\r\n\r\n  .page-container--collapsed {\r\n    inline-size: 0;\r\n  }\r\n}\r\n\r\n@supports not (content-visibility: hidden) {\r\n  .page-container--collapsed,\r\n  .page--hidden {\r\n    display: none; // Destroys the render state. Ctrl + Z and Ctrl + C won't work properly\r\n  }\r\n}\r\n","import {\r\n  Component,\r\n  Element,\r\n  Event,\r\n  EventEmitter,\r\n  Host,\r\n  Method,\r\n  Prop,\r\n  State,\r\n  Watch,\r\n  forceUpdate,\r\n  h\r\n} from \"@stencil/core\";\r\nimport {\r\n  DraggableView,\r\n  DraggableViewInfo,\r\n  FlexibleLayoutWidget\r\n} from \"../flexible-layout/internal/flexible-layout/types\";\r\nimport {\r\n  inBetween,\r\n  isPseudoElementImg,\r\n  isRTL,\r\n  tokenMap\r\n} from \"../../common/utils\";\r\nimport {\r\n  ListDirection,\r\n  ListElementSize,\r\n  ListItemCloseInfo,\r\n  ListSelectedItemInfo\r\n} from \"./types\";\r\nimport {\r\n  CAPTION_ID,\r\n  CLOSE_BUTTON_PART,\r\n  DRAG_PREVIEW,\r\n  DRAG_PREVIEW_ELEMENT,\r\n  DRAG_PREVIEW_INSIDE_BLOCK,\r\n  DRAG_PREVIEW_INSIDE_INLINE,\r\n  DRAG_PREVIEW_OUTSIDE,\r\n  LIST_CLASSES,\r\n  LIST_PART_BLOCK,\r\n  LIST_PART_INLINE,\r\n  PAGE_ID,\r\n  SELECTED_PART\r\n} from \"./utils\";\r\nimport { insertIntoIndex, removeElement } from \"../../common/array\";\r\nimport { focusComposedPath } from \"../common/helpers\";\r\n\r\n// Custom vars\r\nconst TRANSITION_DURATION = \"--ch-list-transition-duration\";\r\n\r\nconst BUTTON_POSITION_X = \"--ch-list-button-position-x\";\r\nconst BUTTON_POSITION_Y = \"--ch-list-button-position-y\";\r\n\r\nconst BUTTON_SIZE = \"--ch-list-button-size\";\r\n\r\nconst MOUSE_OFFSET_X = \"--ch-list-mouse-offset-x\";\r\nconst MOUSE_OFFSET_Y = \"--ch-list-mouse-offset-y\";\r\n\r\nconst MOUSE_POSITION_X = \"--ch-list-mouse-position-x\";\r\nconst MOUSE_POSITION_Y = \"--ch-list-mouse-position-y\";\r\n\r\nconst TAB_LIST_EDGE_START_POSITION = \"--ch-list-tab-list-start\";\r\nconst TAB_LIST_EDGE_END_POSITION = \"--ch-list-tab-list-end\";\r\n\r\nconst DECORATIVE_IMAGE = \"--ch-list-decorative-image\";\r\n\r\n// Key codes\r\nconst ARROW_UP = \"ArrowUp\";\r\nconst ARROW_RIGHT = \"ArrowRight\";\r\nconst ARROW_DOWN = \"ArrowDown\";\r\nconst ARROW_LEFT = \"ArrowLeft\";\r\nconst HOME = \"Home\";\r\nconst END = \"End\";\r\n\r\ntype KeyEvents =\r\n  | typeof ARROW_UP\r\n  | typeof ARROW_RIGHT\r\n  | typeof ARROW_DOWN\r\n  | typeof ARROW_LEFT\r\n  | typeof HOME\r\n  | typeof END;\r\n\r\n// Selectors\r\nconst FIRST_CAPTION_BUTTON = (tabListRef: HTMLElement) =>\r\n  tabListRef.querySelector(\":scope>button\");\r\n\r\nconst LAST_CAPTION_BUTTON = (tabListRef: HTMLElement) =>\r\n  tabListRef.querySelector(\":scope>button:last-child\");\r\n\r\n// Utility functions\r\n\r\nconst isBlockDirection = (direction: ListDirection) => direction === \"block\";\r\n\r\nconst setProperty = (element: HTMLElement, property: string, value: number) =>\r\n  element.style.setProperty(property, `${value}px`);\r\n\r\nconst setButtonInitialPosition = (\r\n  element: HTMLElement,\r\n  positionX: number,\r\n  positionY: number\r\n) => {\r\n  setProperty(element, BUTTON_POSITION_X, positionX);\r\n  setProperty(element, BUTTON_POSITION_Y, positionY);\r\n};\r\n\r\nconst setButtonSize = (element: HTMLElement, size: number) => {\r\n  setProperty(element, BUTTON_SIZE, size);\r\n};\r\n\r\nconst setMousePosition = (\r\n  element: HTMLElement,\r\n  positionX: number,\r\n  positionY: number\r\n) => {\r\n  setProperty(element, MOUSE_POSITION_X, positionX);\r\n  setProperty(element, MOUSE_POSITION_Y, positionY);\r\n};\r\n\r\n// Useful to implement snap to the edges\r\nconst setTabListStartEndPosition = (\r\n  element: HTMLElement,\r\n  startPosition: number,\r\n  endPosition: number\r\n) => {\r\n  setProperty(element, TAB_LIST_EDGE_START_POSITION, startPosition);\r\n  setProperty(element, TAB_LIST_EDGE_END_POSITION, endPosition);\r\n};\r\n\r\nconst getTabListSizesAndSetPosition = (\r\n  hostRef: HTMLChListElement,\r\n  tabListRef: HTMLElement,\r\n  direction: ListDirection,\r\n  buttonRect: DOMRect\r\n): ListElementSize => {\r\n  const tabListRect = tabListRef.getBoundingClientRect();\r\n\r\n  // Tab List information\r\n  const tabListSizes: ListElementSize = {\r\n    xStart: tabListRect.x,\r\n    xEnd: tabListRect.x + tabListRect.width,\r\n    yStart: tabListRect.y,\r\n    yEnd: tabListRect.y + tabListRect.height\r\n  };\r\n\r\n  if (isBlockDirection(direction)) {\r\n    setTabListStartEndPosition(\r\n      hostRef,\r\n      tabListSizes.xStart,\r\n      tabListSizes.xEnd - buttonRect.width\r\n    );\r\n  } else {\r\n    setTabListStartEndPosition(\r\n      hostRef,\r\n      tabListSizes.yStart,\r\n      tabListSizes.yEnd - buttonRect.height\r\n    );\r\n  }\r\n\r\n  return tabListSizes;\r\n};\r\n\r\nconst setMouseOffset = (\r\n  element: HTMLElement,\r\n  offsetX: number,\r\n  offsetY: number\r\n) => {\r\n  setProperty(element, MOUSE_OFFSET_X, offsetX);\r\n  setProperty(element, MOUSE_OFFSET_Y, offsetY);\r\n};\r\n\r\nconst addGrabbingStyle = () =>\r\n  document.body.style.setProperty(\"cursor\", \"grabbing\");\r\nconst removeGrabbingStyle = () => document.body.style.removeProperty(\"cursor\");\r\n\r\nconst focusNextOrPreviousCaption = (\r\n  focusNextSibling: boolean,\r\n  tabListRef: HTMLElement,\r\n  focusedCaption: HTMLButtonElement,\r\n  event: KeyboardEvent\r\n) => {\r\n  // Prevent scroll\r\n  event.preventDefault();\r\n\r\n  let nextFocusedCaption: HTMLButtonElement;\r\n\r\n  // Determine the next selected caption button\r\n  if (focusNextSibling) {\r\n    nextFocusedCaption = (focusedCaption.nextElementSibling ??\r\n      FIRST_CAPTION_BUTTON(tabListRef)) as HTMLButtonElement;\r\n  } else {\r\n    nextFocusedCaption = (focusedCaption.previousElementSibling ??\r\n      LAST_CAPTION_BUTTON(tabListRef)) as HTMLButtonElement;\r\n  }\r\n\r\n  // Focus and select the caption\r\n  nextFocusedCaption.focus();\r\n  nextFocusedCaption.click();\r\n};\r\n\r\n@Component({\r\n  shadow: true,\r\n  styleUrl: \"list.scss\",\r\n  tag: \"ch-list\"\r\n})\r\nexport class ChList implements DraggableView {\r\n  #cancelId: number;\r\n\r\n  // Styling\r\n  #classes: {\r\n    BUTTON?: string;\r\n    IMAGE?: string;\r\n    PAGE?: string;\r\n    PAGE_CONTAINER?: string;\r\n    PAGE_NAME?: string;\r\n    TAB_LIST?: string;\r\n  } = {};\r\n  #parts: {\r\n    BUTTON?: string;\r\n    IMAGE?: string;\r\n    PAGE?: string;\r\n    PAGE_CONTAINER?: string;\r\n    PAGE_NAME?: string;\r\n    TAB_LIST?: string;\r\n  } = {};\r\n\r\n  #selectedIndex: number = -1;\r\n\r\n  #lastDragEvent: MouseEvent;\r\n  #needForRAF = true; // To prevent redundant RAF (request animation frame) calls\r\n\r\n  #initialMousePosition = -1;\r\n\r\n  // Allocated at runtime to reduce memory usage\r\n  #itemSizes: number[];\r\n\r\n  /**\r\n   * This variable represents the boundaries of the box where the mouse can be\r\n   * placed when dragging a caption, to consider that the caption is within the\r\n   * tab list.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #mouseBoundingLimits: ListElementSize;\r\n\r\n  #renderedPages: Set<string> = new Set();\r\n\r\n  // Refs\r\n  #dragPreviewRef: HTMLDivElement;\r\n  #tabListRef: HTMLDivElement;\r\n  #tabPageRef: HTMLDivElement;\r\n\r\n  // Keyboard interactions\r\n  #keyEvents: {\r\n    [key in KeyEvents]: (\r\n      direction: ListDirection,\r\n      event: KeyboardEvent,\r\n      focusedCaption: HTMLButtonElement\r\n    ) => void;\r\n  } = {\r\n    [ARROW_UP]: (direction, ev, focusedButton) => {\r\n      if (direction === \"block\") {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(false, this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [ARROW_RIGHT]: (direction, ev, focusedButton) => {\r\n      if (direction === \"inline\") {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(!isRTL(), this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [ARROW_DOWN]: (direction, ev, focusedButton) => {\r\n      if (direction === \"block\") {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(true, this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [ARROW_LEFT]: (direction, ev, focusedButton) => {\r\n      if (direction === \"inline\") {\r\n        return;\r\n      }\r\n      focusNextOrPreviousCaption(isRTL(), this.#tabListRef, focusedButton, ev);\r\n    },\r\n\r\n    [HOME]: () => {\r\n      const nextFocusedCaption = FIRST_CAPTION_BUTTON(\r\n        this.#tabListRef\r\n      ) as HTMLButtonElement;\r\n\r\n      // Focus and select the caption\r\n      nextFocusedCaption.focus();\r\n      nextFocusedCaption.click();\r\n    },\r\n\r\n    [END]: () => {\r\n      const nextFocusedCaption = LAST_CAPTION_BUTTON(\r\n        this.#tabListRef\r\n      ) as HTMLButtonElement;\r\n\r\n      // Focus and select the caption\r\n      nextFocusedCaption.focus();\r\n      nextFocusedCaption.click();\r\n    }\r\n  };\r\n\r\n  @Element() el: HTMLChListElement;\r\n\r\n  @State() draggedElementIndex = -1;\r\n  @State() draggedElementNewIndex = -1;\r\n\r\n  /**\r\n   * `true` when the mouse position is out of bounds at least once.\r\n   */\r\n  @State() hasCrossedBoundaries = false;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element.\r\n   */\r\n  @Prop() readonly accessibleName: string;\r\n\r\n  /**\r\n   * Specifies a short string, typically 1 to 3 words, that authors associate\r\n   * with an element to provide users of assistive technologies with a label\r\n   * for the element. This label is used for the close button of the captions.\r\n   */\r\n  @Prop() readonly closeButtonAccessibleName: string = \"Close\";\r\n\r\n  /**\r\n   * `true` to hide the close button in the items.\r\n   */\r\n  @Prop() readonly closeButtonHidden: boolean = false;\r\n\r\n  /**\r\n   * Specifies the flexible layout type.\r\n   */\r\n  @Prop({ reflect: true }) readonly direction: ListDirection;\r\n  @Watch(\"direction\")\r\n  directionChange(newDirection: ListDirection) {\r\n    this.#initializeState(newDirection);\r\n  }\r\n\r\n  /**\r\n   * When the control is sortable, the items can be dragged outside of the\r\n   * tab-list. This property lets you specify if this behavior is disabled.\r\n   */\r\n  @Prop() readonly dragOutsideDisabled: boolean = false;\r\n\r\n  /**\r\n   * `true` if the group has is view section expanded. Otherwise, only the\r\n   * toolbar will be displayed.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/ban-default-true\r\n  @Prop() readonly expanded: boolean = true;\r\n\r\n  /**\r\n   * Specifies the items of the tab control.\r\n   */\r\n  @Prop() readonly model: FlexibleLayoutWidget[];\r\n  @Watch(\"model\")\r\n  modelChanged(newModel: FlexibleLayoutWidget[]) {\r\n    this.#updateRenderedPages(newModel);\r\n  }\r\n\r\n  /**\r\n   * Specifies the selected item of the widgets array.\r\n   */\r\n  @Prop({ mutable: true }) selectedId: string;\r\n  @Watch(\"selectedId\")\r\n  handleSelectedIdChange(newSelectedId: string) {\r\n    this.#renderedPages.add(newSelectedId);\r\n  }\r\n\r\n  /**\r\n   * `true` to show the captions of the items.\r\n   */\r\n  @Prop() readonly showCaptions: boolean = true;\r\n\r\n  /**\r\n   * `true` to enable sorting the tab buttons by dragging them in the tab-list.\r\n   * If sortable !== true, the tab buttons can not be dragged out either.\r\n   */\r\n  @Prop() readonly sortable: boolean = false;\r\n\r\n  /**\r\n   * Fired when an item of the main group is double clicked.\r\n   */\r\n  @Event() expandMainGroup: EventEmitter<string>;\r\n\r\n  /**\r\n   * Fired the close button of an item is clicked.\r\n   */\r\n  @Event() itemClose: EventEmitter<ListItemCloseInfo>;\r\n\r\n  /**\r\n   * Fired when the selected item change.\r\n   * This event can be default prevented to prevent the item selection.\r\n   */\r\n  @Event() selectedItemChange: EventEmitter<ListSelectedItemInfo>;\r\n\r\n  /**\r\n   * Fired the first time a caption button is dragged outside of its tab list.\r\n   */\r\n  @Event() itemDragStart: EventEmitter<number>;\r\n\r\n  /**\r\n   * Ends the preview of the dragged item. Useful for ending the preview via\r\n   * keyboard interaction.\r\n   */\r\n  @Method()\r\n  async endDragPreview(): Promise<void> {\r\n    this.#handleDragEnd();\r\n  }\r\n\r\n  /**\r\n   * Returns the info associated to the draggable view.\r\n   */\r\n  @Method()\r\n  async getDraggableViews(): Promise<DraggableViewInfo> {\r\n    return {\r\n      mainView: this.el,\r\n      pageView: this.#tabPageRef,\r\n      tabListView: this.#tabListRef\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Promotes the drag preview to the top layer. Useful to avoid z-index issues.\r\n   */\r\n  @Method()\r\n  async promoteDragPreviewToTopLayer(): Promise<void> {\r\n    if (this.draggedElementIndex === -1) {\r\n      return;\r\n    }\r\n\r\n    // If this property is added in a declarative way via the Stencil's render,\r\n    // we would have to use requestAnimationFrame to delay the shopPopover()\r\n    // method, since the popover defaults to \"auto\", which does not allow to\r\n    // keep multiple \"auto\" popover open at the same time\r\n    this.#dragPreviewRef.popover = \"manual\";\r\n\r\n    this.#dragPreviewRef.showPopover();\r\n  }\r\n\r\n  /**\r\n   * Given an id, remove the page from the render\r\n   */\r\n  @Method()\r\n  async removePage(pageId: string, forceRerender = true) {\r\n    this.#renderedPages.delete(pageId);\r\n\r\n    if (forceRerender) {\r\n      forceUpdate(this);\r\n    }\r\n  }\r\n\r\n  #handleSelectedItemChange =\r\n    (index: number, itemId: string) => (event: MouseEvent) => {\r\n      event.stopPropagation();\r\n\r\n      const eventInfo = this.selectedItemChange.emit({\r\n        lastSelectedIndex: this.#selectedIndex,\r\n        newSelectedId: itemId,\r\n        newSelectedIndex: index\r\n      });\r\n\r\n      if (!eventInfo.defaultPrevented) {\r\n        this.#selectedIndex = index;\r\n        this.selectedId = itemId;\r\n      }\r\n    };\r\n\r\n  /**\r\n   * Make a set based on the rendered items array to maintain order between the\r\n   * pages, even when re-ordering tabs. This is useful for optimizing rendering\r\n   * performance by not re-ordering pages when the caption's order changes.\r\n   */\r\n  // eslint-disable-next-line @stencil-community/own-props-must-be-private\r\n  #updateRenderedPages = (items: FlexibleLayoutWidget[]) => {\r\n    (items ?? []).forEach(item => {\r\n      if (item.wasRendered) {\r\n        this.#renderedPages.add(item.id);\r\n      }\r\n    });\r\n\r\n    // The selected id must be added to the rendered pages, even if it was not\r\n    // marked as \"wasRendered\" in the UI Model\r\n    if (this.selectedId) {\r\n      this.#renderedPages.add(this.selectedId);\r\n    }\r\n  };\r\n\r\n  // #handleItemDblClick = (event: MouseEvent) => {\r\n  //   event.preventDefault();\r\n  //   event.stopPropagation();\r\n\r\n  //   this.expandMainGroup.emit();\r\n  // };\r\n\r\n  #handleDragStart = (index: number) => (event: DragEvent) => {\r\n    // Remove dragover event to allow mousemove event to fire\r\n    event.preventDefault();\r\n\r\n    // Store the index of the dragged element\r\n    this.draggedElementIndex = index;\r\n\r\n    // - - - - - - - - - - - DOM read operations - - - - - - - - - - -\r\n    const mousePositionX = event.clientX;\r\n    const mousePositionY = event.clientY;\r\n    const direction = this.direction;\r\n\r\n    const getItemSize = isBlockDirection(direction)\r\n      ? (item: HTMLElement) => item.getBoundingClientRect().width\r\n      : (item: HTMLElement) => item.getBoundingClientRect().height;\r\n    this.#itemSizes = [...this.#tabListRef.children].map(getItemSize);\r\n\r\n    const buttonRect = (\r\n      event.target as HTMLButtonElement\r\n    ).getBoundingClientRect();\r\n\r\n    // Tab List information\r\n    const tabListSizes = getTabListSizesAndSetPosition(\r\n      this.el,\r\n      this.#tabListRef,\r\n      direction,\r\n      buttonRect\r\n    );\r\n\r\n    // Button information\r\n    const buttonSizes: ListElementSize = {\r\n      xStart: buttonRect.x,\r\n      xEnd: buttonRect.x + buttonRect.width,\r\n      yStart: buttonRect.y,\r\n      yEnd: buttonRect.y + buttonRect.height\r\n    };\r\n\r\n    const mouseDistanceToButtonTopEdge = mousePositionY - buttonSizes.yStart;\r\n    const mouseDistanceToButtonBottomEdge = buttonSizes.yEnd - mousePositionY;\r\n    const mouseDistanceToButtonLeftEdge = mousePositionX - buttonSizes.xStart;\r\n    const mouseDistanceToButtonRightEdge = buttonSizes.xEnd - mousePositionX;\r\n\r\n    // Update mouse limits if drag outside is enabled\r\n    if (!this.dragOutsideDisabled) {\r\n      this.#mouseBoundingLimits = {\r\n        xStart: tabListSizes.xStart - mouseDistanceToButtonRightEdge,\r\n        xEnd: tabListSizes.xEnd + mouseDistanceToButtonLeftEdge,\r\n        yStart: tabListSizes.yStart - mouseDistanceToButtonBottomEdge,\r\n        yEnd: tabListSizes.yEnd + mouseDistanceToButtonTopEdge\r\n      };\r\n    }\r\n\r\n    // Store initial mouse position\r\n    this.#initialMousePosition = isBlockDirection(direction)\r\n      ? mousePositionX\r\n      : mousePositionY;\r\n\r\n    // - - - - - - - - - - - DOM write operations - - - - - - - - - - -\r\n    // Initialize mouse position to avoid initial flickering\r\n    setMousePosition(this.el, mousePositionX, mousePositionY);\r\n\r\n    // Initialize the button position\r\n    setButtonInitialPosition(this.el, buttonSizes.xStart, buttonSizes.yStart);\r\n\r\n    setButtonSize(\r\n      this.el,\r\n      isBlockDirection(direction) ? buttonRect.width : buttonRect.height\r\n    );\r\n\r\n    // Update mouse offset to correctly place the dragged element preview\r\n    setMouseOffset(\r\n      this.el,\r\n      mouseDistanceToButtonLeftEdge,\r\n      mouseDistanceToButtonTopEdge\r\n    );\r\n\r\n    addGrabbingStyle();\r\n\r\n    // Add listeners\r\n    document.addEventListener(\"mousemove\", this.#handleItemDrag, {\r\n      capture: true,\r\n      passive: true\r\n    });\r\n\r\n    document.addEventListener(\"mouseup\", this.#handleDragEnd, {\r\n      capture: true\r\n    });\r\n  };\r\n\r\n  #handleDragEnd = () => {\r\n    // Since mousemove callbacks are executed on animation frames, we must also\r\n    // remove the events on animations frame. Otherwise we would remove the\r\n    // events and in the next frame the mousemove handler will be executes\r\n    cancelAnimationFrame(this.#cancelId);\r\n    this.#needForRAF = true;\r\n\r\n    document.removeEventListener(\"mousemove\", this.#handleItemDrag, {\r\n      capture: true\r\n    });\r\n\r\n    document.removeEventListener(\"mouseup\", this.#handleDragEnd, {\r\n      capture: true\r\n    });\r\n\r\n    removeGrabbingStyle();\r\n\r\n    const anItemWasReordered =\r\n      !this.hasCrossedBoundaries &&\r\n      this.draggedElementNewIndex !== this.draggedElementIndex;\r\n\r\n    // Move the item to the new position\r\n    if (anItemWasReordered) {\r\n      const itemToInsert = removeElement(this.model, this.draggedElementIndex);\r\n      insertIntoIndex(this.model, itemToInsert, this.draggedElementNewIndex);\r\n\r\n      // Update last selected index\r\n      this.#adjustLastSelectedIndexValueAfterReorder();\r\n    }\r\n\r\n    // Restore visibility of the dragged element\r\n    this.draggedElementIndex = -1;\r\n    this.draggedElementNewIndex = -1;\r\n\r\n    // Free the memory\r\n    this.#itemSizes = undefined;\r\n\r\n    // Reset state\r\n    this.hasCrossedBoundaries = false;\r\n    this.el.style.removeProperty(TRANSITION_DURATION);\r\n  };\r\n\r\n  #adjustLastSelectedIndexValueAfterReorder = () => {\r\n    // If the dragged element is the selected element, use the new index\r\n    if (this.#selectedIndex === this.draggedElementIndex) {\r\n      this.#selectedIndex = this.draggedElementNewIndex;\r\n    }\r\n    // Dragged element:\r\n    //   - Started: Before the selected index\r\n    //   - Ended: After the selected index or in the same position\r\n    else if (\r\n      this.draggedElementIndex < this.#selectedIndex &&\r\n      this.#selectedIndex <= this.draggedElementNewIndex\r\n    ) {\r\n      this.#selectedIndex--;\r\n    }\r\n    // Dragged element:\r\n    //   - Started: After the selected index\r\n    //   - Ended: Before the selected index or in the same position\r\n    else if (\r\n      this.#selectedIndex < this.draggedElementIndex &&\r\n      this.draggedElementNewIndex <= this.#selectedIndex\r\n    ) {\r\n      this.#selectedIndex++;\r\n    }\r\n  };\r\n\r\n  #handleItemDrag = (event: MouseEvent) => {\r\n    this.#lastDragEvent = event;\r\n\r\n    if (!this.#needForRAF) {\r\n      return;\r\n    }\r\n    this.#needForRAF = false; // No need to call RAF up until next frame\r\n\r\n    this.#cancelId = requestAnimationFrame(() => {\r\n      this.#needForRAF = true; // RAF now consumes the movement instruction so a new one can come\r\n\r\n      const mousePositionX = this.#lastDragEvent.clientX;\r\n      const mousePositionY = this.#lastDragEvent.clientY;\r\n\r\n      setMousePosition(this.el, mousePositionX, mousePositionY);\r\n\r\n      // There is no need to update the preview of the reorder\r\n      if (this.hasCrossedBoundaries) {\r\n        return;\r\n      }\r\n\r\n      const mouseLimits = this.#mouseBoundingLimits;\r\n\r\n      // Check mouse limits if drag outside is enabled\r\n      if (!this.dragOutsideDisabled) {\r\n        const draggedButtonIsInsideTheTabList =\r\n          inBetween(mouseLimits.xStart, mousePositionX, mouseLimits.xEnd) &&\r\n          inBetween(mouseLimits.yStart, mousePositionY, mouseLimits.yEnd);\r\n\r\n        // Emit the itemDragStart event the first time the button is out of the\r\n        // mouse bounds (`mouseBoundingLimits`)\r\n        if (!draggedButtonIsInsideTheTabList) {\r\n          this.hasCrossedBoundaries = true;\r\n\r\n          // Remove transition before the render to avoid flickering in the animation\r\n          this.el.style.setProperty(TRANSITION_DURATION, \"0s\");\r\n\r\n          this.itemDragStart.emit(this.draggedElementIndex);\r\n          return;\r\n        }\r\n      }\r\n\r\n      // There is no need to re-order the items in the preview\r\n      if (this.model.length === 1) {\r\n        return;\r\n      }\r\n\r\n      // In this point, the preview is inside the tab list, we should check\r\n      // in which place is the preview to give feedback for the item's reorder\r\n      const mousePosition = isBlockDirection(this.direction)\r\n        ? mousePositionX\r\n        : mousePositionY;\r\n\r\n      const hasMovedToTheEnd = this.#initialMousePosition < mousePosition;\r\n\r\n      // Distance traveled from the initial mouse position\r\n      let distanceTraveled = Math.abs(\r\n        this.#initialMousePosition - mousePosition\r\n      );\r\n\r\n      let newIndex = this.draggedElementIndex;\r\n\r\n      if (hasMovedToTheEnd) {\r\n        // While it is not the last item and the distance traveled is greater\r\n        // than half the size of the next item\r\n        while (\r\n          newIndex < this.model.length - 1 &&\r\n          distanceTraveled - this.#itemSizes[newIndex + 1] / 2 > 0\r\n        ) {\r\n          distanceTraveled -= this.#itemSizes[newIndex + 1];\r\n          newIndex++;\r\n        }\r\n      } else {\r\n        // While it is not the first item and the distance traveled is greater\r\n        // than half the size of the previous item\r\n        while (\r\n          newIndex > 0 &&\r\n          distanceTraveled - this.#itemSizes[newIndex - 1] / 2 > 0\r\n        ) {\r\n          distanceTraveled -= this.#itemSizes[newIndex - 1];\r\n          newIndex--;\r\n        }\r\n      }\r\n\r\n      // Check if should update the dragged element index in the preview\r\n      if (this.draggedElementNewIndex !== newIndex) {\r\n        this.draggedElementNewIndex = newIndex;\r\n      }\r\n    });\r\n  };\r\n\r\n  #handleClose = (index: number, itemId: string) => (event: MouseEvent) => {\r\n    event.preventDefault();\r\n    event.stopPropagation();\r\n\r\n    this.itemClose.emit({\r\n      itemIndex: index,\r\n      itemId: itemId\r\n    });\r\n  };\r\n\r\n  #handleTabFocus = (event: KeyboardEvent) => {\r\n    if (this.model.length < 2) {\r\n      return;\r\n    }\r\n\r\n    const keyEventHandler = this.#keyEvents[event.code];\r\n    if (!keyEventHandler) {\r\n      return;\r\n    }\r\n\r\n    const currentFocusedCaption = focusComposedPath()[0].closest(\r\n      \".\" + this.#classes.BUTTON\r\n    ) as HTMLButtonElement;\r\n\r\n    keyEventHandler(this.direction, event, currentFocusedCaption);\r\n  };\r\n\r\n  #imgRender = (item: FlexibleLayoutWidget) =>\r\n    item.startImageType === \"img\" &&\r\n    item.startImageSrc && (\r\n      <img\r\n        aria-hidden=\"true\"\r\n        class={\"caption-image \" + this.#classes.IMAGE}\r\n        part={this.#parts.IMAGE}\r\n        alt=\"\"\r\n        src={item.startImageSrc}\r\n        loading=\"lazy\"\r\n      />\r\n    );\r\n\r\n  #renderTabBar = (thereAreShiftedElements: boolean) => (\r\n    <div\r\n      role=\"tablist\"\r\n      aria-label={this.accessibleName}\r\n      class={this.#classes.TAB_LIST}\r\n      part={this.#parts.TAB_LIST}\r\n      ref={el => (this.#tabListRef = el)}\r\n      onKeyDown={this.#handleTabFocus}\r\n    >\r\n      {this.model.map((item, index) => (\r\n        <button\r\n          key={CAPTION_ID(item.id)}\r\n          id={CAPTION_ID(item.id)}\r\n          role=\"tab\"\r\n          aria-controls={PAGE_ID(item.id)}\r\n          aria-label={!this.showCaptions ? item.name : null}\r\n          aria-selected={(item.id === this.selectedId).toString()}\r\n          class={{\r\n            [this.#classes.BUTTON]: true,\r\n            \"decorative-image\": isPseudoElementImg(\r\n              item.startImageSrc,\r\n              item.startImageType\r\n            ),\r\n\r\n            \"dragged-element\": this.draggedElementIndex === index,\r\n            \"dragged-element--outside\":\r\n              this.draggedElementIndex === index &&\r\n              this.hasCrossedBoundaries &&\r\n              this.model.length > 1,\r\n            \"shifted-element\": this.draggedElementIndex !== -1,\r\n\r\n            \"shifted-element--start\":\r\n              thereAreShiftedElements &&\r\n              this.draggedElementIndex < index &&\r\n              index <= this.draggedElementNewIndex,\r\n\r\n            \"shifted-element--end\":\r\n              thereAreShiftedElements &&\r\n              this.draggedElementNewIndex <= index &&\r\n              index < this.draggedElementIndex,\r\n\r\n            sortable: this.sortable\r\n          }}\r\n          part={tokenMap({\r\n            [this.#parts.BUTTON]: true,\r\n            [CAPTION_ID(item.id)]: true,\r\n            [SELECTED_PART]: item.id === this.selectedId\r\n          })}\r\n          style={\r\n            isPseudoElementImg(item.startImageSrc, item.startImageType)\r\n              ? { [DECORATIVE_IMAGE]: `url(\"${item.startImageSrc}\")` }\r\n              : null\r\n          }\r\n          onAuxClick={this.#handleClose(index, item.id)}\r\n          onClick={\r\n            !(item.id === this.selectedId)\r\n              ? this.#handleSelectedItemChange(index, item.id)\r\n              : null\r\n          }\r\n          // onDblClick={\r\n          //   this.direction === \"main\" ? this.#handleItemDblClick : null\r\n          // }\r\n          // Drag and drop\r\n          onDragStart={this.sortable ? this.#handleDragStart(index) : null}\r\n        >\r\n          {this.#imgRender(item)}\r\n\r\n          {this.showCaptions && item.name}\r\n\r\n          {!this.closeButtonHidden && (\r\n            <button\r\n              aria-label={this.closeButtonAccessibleName}\r\n              class=\"close-button\"\r\n              part={CLOSE_BUTTON_PART}\r\n              type=\"button\"\r\n              onClick={this.#handleClose(index, item.id)}\r\n            ></button>\r\n          )}\r\n        </button>\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  #renderTabPages = () => (\r\n    <div\r\n      class={{\r\n        [this.#classes.PAGE_CONTAINER]: true,\r\n        \"page-container\": true,\r\n        \"page-container--collapsed\": !this.expanded\r\n      }}\r\n      part={this.#parts.PAGE_CONTAINER}\r\n      ref={el => (this.#tabPageRef = el)}\r\n    >\r\n      {[...this.#renderedPages.keys()].map(itemId => (\r\n        <div\r\n          key={PAGE_ID(itemId)}\r\n          id={PAGE_ID(itemId)}\r\n          role=\"tabpanel\"\r\n          aria-labelledby={CAPTION_ID(itemId)}\r\n          class={{\r\n            [this.#classes.PAGE]: true,\r\n            \"page--selected\": itemId === this.selectedId,\r\n            \"page--hidden\": !(itemId === this.selectedId)\r\n          }}\r\n          part={this.#parts.PAGE}\r\n        >\r\n          <slot name={itemId} />\r\n        </div>\r\n      ))}\r\n    </div>\r\n  );\r\n\r\n  #renderDragPreview = (draggedElement: FlexibleLayoutWidget) => {\r\n    const classes = {\r\n      [DRAG_PREVIEW]: true,\r\n      [DRAG_PREVIEW_OUTSIDE]: this.hasCrossedBoundaries,\r\n\r\n      [DRAG_PREVIEW_INSIDE_INLINE]:\r\n        !this.hasCrossedBoundaries && !isBlockDirection(this.direction),\r\n\r\n      [DRAG_PREVIEW_INSIDE_BLOCK]:\r\n        !this.hasCrossedBoundaries && isBlockDirection(this.direction)\r\n    };\r\n\r\n    const decorativeImage = isPseudoElementImg(\r\n      draggedElement.startImageSrc,\r\n      draggedElement.startImageType\r\n    );\r\n\r\n    return (\r\n      <div\r\n        aria-hidden=\"true\"\r\n        class={classes}\r\n        part={tokenMap(classes)}\r\n        ref={el => (this.#dragPreviewRef = el)}\r\n      >\r\n        <button\r\n          class={{\r\n            [this.#classes.BUTTON]: true,\r\n            [DRAG_PREVIEW_ELEMENT]: true,\r\n            \"decorative-image\": decorativeImage\r\n          }}\r\n          part={tokenMap({\r\n            [this.#parts.BUTTON]: true,\r\n            [CAPTION_ID(draggedElement.id)]: true,\r\n            [DRAG_PREVIEW_ELEMENT]: true,\r\n            [SELECTED_PART]: draggedElement.id === this.selectedId\r\n          })}\r\n          style={\r\n            decorativeImage\r\n              ? { [DECORATIVE_IMAGE]: `url(\"${draggedElement.startImageSrc}\")` }\r\n              : null\r\n          }\r\n        >\r\n          {this.#imgRender(draggedElement)}\r\n\r\n          {this.showCaptions && draggedElement.name}\r\n        </button>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  #initializeState = (direction: ListDirection) => {\r\n    this.#updateRenderedPages(this.model);\r\n\r\n    // Initialize classes and parts\r\n    this.#setClassesAndParts(direction);\r\n  };\r\n\r\n  #setClassesAndParts = (direction: ListDirection) => {\r\n    this.#classes = LIST_CLASSES;\r\n    this.#parts = direction === \"block\" ? LIST_PART_BLOCK : LIST_PART_INLINE;\r\n  };\r\n\r\n  componentWillLoad() {\r\n    this.#initializeState(this.direction);\r\n  }\r\n\r\n  render() {\r\n    if (this.model == null || this.model.length === 0) {\r\n      return \"\";\r\n    }\r\n\r\n    const draggedIndex = this.draggedElementIndex;\r\n    const draggedElement = this.model[draggedIndex];\r\n    const thereAreShiftedElementsInPreview =\r\n      !this.hasCrossedBoundaries &&\r\n      this.draggedElementNewIndex !== -1 &&\r\n      this.draggedElementIndex !== this.draggedElementNewIndex;\r\n\r\n    return (\r\n      <Host class={`ch-list-direction--${this.direction}`}>\r\n        {this.#renderTabBar(thereAreShiftedElementsInPreview)}\r\n        {this.#renderTabPages()}\r\n\r\n        {draggedIndex !== -1 && this.#renderDragPreview(draggedElement)}\r\n      </Host>\r\n    );\r\n  }\r\n}\r\n"],"mappings":"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"}