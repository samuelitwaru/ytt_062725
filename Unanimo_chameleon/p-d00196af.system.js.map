{"version":3,"names":["_SyncWithRAF_needForRAF","set","this","_SyncWithRAF_computationId","SyncWithRAF","prototype","perform","computationInFrame","computationBeforeFrame","_this","__classPrivateFieldGet","__classPrivateFieldSet","requestAnimationFrame","cancel","cancelAnimationFrame"],"sources":["src/common/sync-with-frames.ts"],"sourcesContent":["export class SyncWithRAF {\r\n  #needForRAF = true; // To prevent redundant RAF (request animation frame) calls\r\n  #computationId: number;\r\n\r\n  /**\r\n   * Perform a computation in the next frame. If this method is called multiple\r\n   * times before the next frame, only the first call will be executed in the\r\n   * frame.\r\n   * @param computationInFrame Computation to perform in the frame\r\n   * @param computationBeforeFrame Computation to perform in each call of this method. This computation is not synced with the frames.\r\n   */\r\n  perform(computationInFrame: () => void, computationBeforeFrame?: () => void) {\r\n    if (computationBeforeFrame) {\r\n      computationBeforeFrame();\r\n    }\r\n\r\n    if (!this.#needForRAF) {\r\n      return;\r\n    }\r\n    this.#needForRAF = false; // No need to call RAF up until next frame\r\n\r\n    this.#computationId = requestAnimationFrame(() => {\r\n      this.#needForRAF = true; // RAF now consumes the movement instruction so a new one can come\r\n\r\n      computationInFrame();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cancel the computation queued in the next frame.\r\n   */\r\n  cancel() {\r\n    cancelAnimationFrame(this.#computationId);\r\n    this.#needForRAF = true;\r\n  }\r\n}\r\n"],"mappings":"63BACEA,EAAAC,IAAAC,KAAc,MACdC,EAAAF,IAAAC,UAAA,E,CASAE,EAAAC,UAAAC,QAAA,SAAQC,EAAgCC,GAAxC,IAAAC,EAAAP,KACE,GAAIM,EAAwB,CAC1BA,G,CAGF,IAAKE,uBAAAR,KAAIF,EAAA,KAAc,CACrB,M,CAEFW,uBAAAT,KAAIF,EAAe,MAAK,KAExBW,uBAAAT,KAAIC,EAAkBS,uBAAsB,WAC1CD,uBAAAF,EAAIT,EAAe,KAAI,KAEvBO,G,IACA,I,EAMJH,EAAAC,UAAAQ,OAAA,WACEC,qBAAqBJ,uBAAAR,KAAIC,EAAA,MACzBQ,uBAAAT,KAAIF,EAAe,KAAI,I"}