{"version":3,"names":["intersectionObserverCss","ChIntersectionObserverStyle0","REGEX_TO_REPLACE_PERCENTAGE","REGEX_TO_TEST_DIP","REGEX_TO_TEST_PERCENTAGE","IntersectionObserverControl","exports","this","defaultThreshold","rootMarginString","class_1","prototype","checkValidDipValue","dipValue","test","convertDipToPxValue","checkValidPercentValue","percentValue","aux","replace","split","join","convertThresholdValueToNumber","threshold","Number","parseThreshold","_this","finalThresholds","thresholdsToParse","forEach","thresholdValue","convertedNumber","push","setIntersectionObserver","options","root","rootElement","rootMargin","observer","IntersectionObserver","entries","intersectionUpdate","emit","childElement","getChildElement","observe","element","firstElementChild","getComputedStyle","display","setIntersectionObserverOptionsFromProperties","document","getElementById","validatePosition","topMargin","leftMargin","bottomMargin","rightMargin","position","endsWith","componentDidLoad","disconnectedCallback","disconnect","undefined","render","h","key","name"],"sources":["src/components/intersection-observer/intersection-observer.scss?tag=ch-intersection-observer&encapsulation=shadow","src/components/intersection-observer/intersection-observer.tsx"],"sourcesContent":[":host {\r\n  display: contents;\r\n}\r\n","import {\r\n  Component,\r\n  h,\r\n  EventEmitter,\r\n  Event,\r\n  Element,\r\n  Prop\r\n} from \"@stencil/core\";\r\n\r\nconst REGEX_TO_REPLACE_PERCENTAGE = /%/g;\r\nconst REGEX_TO_TEST_DIP = /^\\d+(dip)?$/;\r\nconst REGEX_TO_TEST_PERCENTAGE = /^\\d+(%)?$/;\r\n\r\n@Component({\r\n  tag: \"ch-intersection-observer\",\r\n  styleUrl: \"intersection-observer.scss\",\r\n  shadow: true\r\n})\r\nexport class IntersectionObserverControl {\r\n  private defaultThreshold: Array<number> = [0];\r\n  private observer: IntersectionObserver;\r\n  private rootElement: HTMLElement;\r\n  private rootMarginString = \"\";\r\n\r\n  @Element() element: HTMLChIntersectionObserverElement;\r\n\r\n  /**\r\n   * Bottom margin around the root element\r\n   */\r\n  @Prop() readonly bottomMargin: string;\r\n\r\n  /**\r\n   * Left margin around the root element\r\n   */\r\n  @Prop() readonly leftMargin: string;\r\n\r\n  /**\r\n   * Right margin around the root element\r\n   */\r\n  @Prop() readonly rightMargin: string;\r\n\r\n  /**\r\n   *  Set the ID of the component that is used as the viewport, default is the browser.\r\n   */\r\n  @Prop() readonly root: string;\r\n\r\n  /**\r\n   * Numeric values representing percentages of the target element which are visible.\r\n   */\r\n  @Prop() readonly threshold: string;\r\n\r\n  /**\r\n   * Top margin around the root element\r\n   */\r\n  @Prop() readonly topMargin: string;\r\n\r\n  /**\r\n   * Emitted whenever the control reaches a threshold specified by the threshold property\r\n   * @param IntersectionObserverEntry Details of intersection object.\r\n   */\r\n  @Event() intersectionUpdate: EventEmitter<IntersectionObserverEntry>;\r\n\r\n  /**\r\n   * Used to check that the passed value is a valid device-independent-pixel (dip)\r\n   * value, and transform the dip to `px` value.\r\n   * @example\r\n   * Input: \"200dip\" Output: \"200px\"\r\n   * Input: \"50%\" Output: \"0px\"\r\n   * @param percentValue Represent the given dip value\r\n   * @returns When is a valid dip value returns the value converted to pixels. Otherwise returns \"0px\".\r\n   */\r\n  private checkValidDipValue(dipValue: string) {\r\n    return REGEX_TO_TEST_DIP.test(dipValue)\r\n      ? this.convertDipToPxValue(dipValue)\r\n      : \"0px\";\r\n  }\r\n\r\n  /**\r\n   * Used to check that the passed value is a valid percentage. @example: \"200%\"\r\n   * @param percentValue : Represent the given percentage value\r\n   * @returns When is a valid percentage value returns the value, otherwise returns \"0px\"\r\n   */\r\n  private checkValidPercentValue(percentValue: string) {\r\n    return REGEX_TO_TEST_PERCENTAGE.test(percentValue) ? percentValue : \"0px\";\r\n  }\r\n\r\n  /**\r\n   * @todo TODO: Simplify this implementation\r\n   * Transform the given dip value to pixels\r\n   * @param dipValue Represent the given dip value @example \"10dip\"\r\n   * @returns Returns the given value converted to px @example \"10px\"\r\n   */\r\n  private convertDipToPxValue(dipValue: string) {\r\n    const aux = dipValue.replace(\"dip\", \"px\");\r\n    return aux.split(\" \").join(\"\");\r\n  }\r\n\r\n  /**\r\n   * Convert the given percentages string representing a threshold value in decimal value\r\n   * @param threshold Threshold string representation @example: \"10%\"\r\n   * @returns Decimal value between 0 and 1 @example: 0.1\r\n   */\r\n  private convertThresholdValueToNumber(threshold: string) {\r\n    if (REGEX_TO_TEST_PERCENTAGE.test(threshold)) {\r\n      return Number(threshold.replace(REGEX_TO_REPLACE_PERCENTAGE, \"\")) / 100;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Create a valid Javascript IntersectionObserver API threshold  options value\r\n   * @param threshold Threshold string representation @example: \"10%,30%,40%\"\r\n   * @returns Valid array of numbers in the range between 0 and 1 @example: [0.1, 0.3, 0.4]\r\n   */\r\n  private parseThreshold(threshold: string): number[] {\r\n    if (!threshold) {\r\n      return [0];\r\n    }\r\n\r\n    const finalThresholds: number[] = [];\r\n    const thresholdsToParse = threshold.split(\",\");\r\n\r\n    thresholdsToParse.forEach(thresholdValue => {\r\n      const convertedNumber =\r\n        this.convertThresholdValueToNumber(thresholdValue);\r\n\r\n      if (convertedNumber <= 1) {\r\n        finalThresholds.push(convertedNumber);\r\n      }\r\n    });\r\n    return finalThresholds;\r\n  }\r\n\r\n  /**\r\n   * Initialize intersection observer with its options and start observing\r\n   */\r\n  private setIntersectionObserver() {\r\n    const options: IntersectionObserverInit = {\r\n      root: this.rootElement,\r\n      rootMargin: this.rootMarginString,\r\n      threshold: this.defaultThreshold\r\n    };\r\n    this.observer = new IntersectionObserver(entries => {\r\n      this.intersectionUpdate.emit(entries[0]);\r\n    }, options);\r\n\r\n    const childElement = this.getChildElement();\r\n\r\n    if (childElement) {\r\n      this.observer.observe(childElement);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns The first child element that its display CSS property is different from `contents`\r\n   */\r\n  private getChildElement() {\r\n    let childElement = this.element.firstElementChild as HTMLElement;\r\n\r\n    while (\r\n      childElement &&\r\n      getComputedStyle(childElement).display === \"contents\"\r\n    ) {\r\n      childElement = childElement.firstElementChild as HTMLElement;\r\n    }\r\n    return childElement;\r\n  }\r\n\r\n  /**\r\n   * Transform the given initial intersection-observer component properties\r\n   * into Javascript IntersectionObserver API options valid values.\r\n   */\r\n  private setIntersectionObserverOptionsFromProperties() {\r\n    if (this.root) {\r\n      this.rootElement = document.getElementById(this.root);\r\n    }\r\n    this.rootMarginString = [\r\n      this.validatePosition(this.topMargin),\r\n      this.validatePosition(this.leftMargin),\r\n      this.validatePosition(this.bottomMargin),\r\n      this.validatePosition(this.rightMargin)\r\n    ].join(\" \");\r\n\r\n    this.defaultThreshold = this.parseThreshold(this.threshold);\r\n  }\r\n\r\n  /**\r\n   * Check that the given string value is a valid percentage or device\r\n   * independent pixel (dip) value.\r\n   * @param position Represent the given dip or px value\r\n   */\r\n  private validatePosition(position: string) {\r\n    if (position && position.endsWith(\"dip\")) {\r\n      return this.checkValidDipValue(position);\r\n    }\r\n    return this.checkValidPercentValue(position);\r\n  }\r\n\r\n  componentDidLoad() {\r\n    this.setIntersectionObserverOptionsFromProperties();\r\n    this.setIntersectionObserver();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = undefined;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return <slot name=\"content\" />;\r\n  }\r\n}\r\n"],"mappings":"0JAAA,IAAMA,EAA0B,0BAChC,IAAAC,EAAeD,ECQf,IAAME,EAA8B,KACpC,IAAMC,EAAoB,cAC1B,IAAMC,EAA2B,Y,IAOpBC,EAA2BC,EAAA,sC,cAC9BC,KAAAC,iBAAkC,CAAC,GAGnCD,KAAAE,iBAAmB,G,yUAiDnBC,EAAAC,UAAAC,mBAAA,SAAmBC,GACzB,OAAOV,EAAkBW,KAAKD,GAC1BN,KAAKQ,oBAAoBF,GACzB,K,EAQEH,EAAAC,UAAAK,uBAAA,SAAuBC,GAC7B,OAAOb,EAAyBU,KAAKG,GAAgBA,EAAe,K,EAS9DP,EAAAC,UAAAI,oBAAA,SAAoBF,GAC1B,IAAMK,EAAML,EAASM,QAAQ,MAAO,MACpC,OAAOD,EAAIE,MAAM,KAAKC,KAAK,G,EAQrBX,EAAAC,UAAAW,8BAAA,SAA8BC,GACpC,GAAInB,EAAyBU,KAAKS,GAAY,CAC5C,OAAOC,OAAOD,EAAUJ,QAAQjB,EAA6B,KAAO,G,CAGtE,OAAO,C,EAQDQ,EAAAC,UAAAc,eAAA,SAAeF,GAAf,IAAAG,EAAAnB,KACN,IAAKgB,EAAW,CACd,MAAO,CAAC,E,CAGV,IAAMI,EAA4B,GAClC,IAAMC,EAAoBL,EAAUH,MAAM,KAE1CQ,EAAkBC,SAAQ,SAAAC,GACxB,IAAMC,EACJL,EAAKJ,8BAA8BQ,GAErC,GAAIC,GAAmB,EAAG,CACxBJ,EAAgBK,KAAKD,E,KAGzB,OAAOJ,C,EAMDjB,EAAAC,UAAAsB,wBAAA,eAAAP,EAAAnB,KACN,IAAM2B,EAAoC,CACxCC,KAAM5B,KAAK6B,YACXC,WAAY9B,KAAKE,iBACjBc,UAAWhB,KAAKC,kBAElBD,KAAK+B,SAAW,IAAIC,sBAAqB,SAAAC,GACvCd,EAAKe,mBAAmBC,KAAKF,EAAQ,G,GACpCN,GAEH,IAAMS,EAAepC,KAAKqC,kBAE1B,GAAID,EAAc,CAChBpC,KAAK+B,SAASO,QAAQF,E,GAOlBjC,EAAAC,UAAAiC,gBAAA,WACN,IAAID,EAAepC,KAAKuC,QAAQC,kBAEhC,MACEJ,GACAK,iBAAiBL,GAAcM,UAAY,WAC3C,CACAN,EAAeA,EAAaI,iB,CAE9B,OAAOJ,C,EAODjC,EAAAC,UAAAuC,6CAAA,WACN,GAAI3C,KAAK4B,KAAM,CACb5B,KAAK6B,YAAce,SAASC,eAAe7C,KAAK4B,K,CAElD5B,KAAKE,iBAAmB,CACtBF,KAAK8C,iBAAiB9C,KAAK+C,WAC3B/C,KAAK8C,iBAAiB9C,KAAKgD,YAC3BhD,KAAK8C,iBAAiB9C,KAAKiD,cAC3BjD,KAAK8C,iBAAiB9C,KAAKkD,cAC3BpC,KAAK,KAEPd,KAAKC,iBAAmBD,KAAKkB,eAAelB,KAAKgB,U,EAQ3Cb,EAAAC,UAAA0C,iBAAA,SAAiBK,GACvB,GAAIA,GAAYA,EAASC,SAAS,OAAQ,CACxC,OAAOpD,KAAKK,mBAAmB8C,E,CAEjC,OAAOnD,KAAKS,uBAAuB0C,E,EAGrChD,EAAAC,UAAAiD,iBAAA,WACErD,KAAK2C,+CACL3C,KAAK0B,yB,EAGPvB,EAAAC,UAAAkD,qBAAA,WACE,GAAItD,KAAK+B,SAAU,CACjB/B,KAAK+B,SAASwB,aACdvD,KAAK+B,SAAWyB,S,GAIpBrD,EAAAC,UAAAqD,OAAA,WACE,OAAOC,EAAA,QAAAC,IAAA,2CAAMC,KAAK,W,WAlMkB,I"}