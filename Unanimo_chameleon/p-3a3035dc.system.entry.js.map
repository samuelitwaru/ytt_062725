{"version":3,"names":["iconContent","Map","requests","getSvgContent","url","request","get","fetch","then","response","ok","text","svgContent","set","iconCss","ChIconStyle0","ChIcon","exports","class_1","prototype","connectedCallback","_this","this","waitUntilVisible","element","isVisible","getIcon","disconnectedCallback","io","undefined","disconnect","el","rootMargin","callback","lazy","window","IntersectionObserver","io_1","data","isIntersecting","observe","src","has","_a","_b","sent","render","h","key","innerHTML"],"sources":["src/deprecated-components/icon/requests.ts","src/deprecated-components/icon/icon.scss?tag=ch-icon&encapsulation=shadow","src/deprecated-components/icon/icon.tsx"],"sourcesContent":["export const iconContent = new Map<string, string>();\r\nconst requests = new Map<string, Promise<any>>();\r\n\r\nexport function getSvgContent(url: string) {\r\n  // see if we already have a request for this url\r\n  let request = requests.get(url);\r\n\r\n  if (!request) {\r\n    // we don't already have a request\r\n    // @ts-expect-error: This implementation is deprecated, so we are avoiding this error\r\n    request = fetch(url).then(response => {\r\n      if (response.ok) {\r\n        return response.text().then(svgContent => {\r\n          iconContent.set(url, svgContent);\r\n          return svgContent;\r\n        });\r\n      }\r\n      iconContent.set(url, \"\");\r\n    });\r\n\r\n    // cache for the same requests\r\n    requests.set(url, request);\r\n  }\r\n\r\n  return request;\r\n}\r\n",":host(:not([auto-color])) {\r\n  /**\r\n  * @prop --icon-color: Color of the icon (sets the SVG's `fill` property)\r\n  */\r\n  svg {\r\n    * {\r\n      fill: var(--icon-color) !important;\r\n    }\r\n  }\r\n\r\n  //Composed icons colors\r\n  path.icons01 {\r\n    fill: var(--icons01-enabled);\r\n  }\r\n  path.icons02 {\r\n    fill: var(--icons02-enabled);\r\n  }\r\n  path.icons03 {\r\n    fill: var(--icons03-enabled);\r\n  }\r\n  path.icons04 {\r\n    fill: var(--icons04-enabled);\r\n  }\r\n  path.icons05 {\r\n    fill: var(--icons05-enabled);\r\n  }\r\n  path.icons06 {\r\n    fill: var(--icons06-enabled);\r\n  }\r\n  path.icons07 {\r\n    fill: var(--icons07-enabled);\r\n  }\r\n  path.icons08 {\r\n    fill: var(--icons08-enabled);\r\n  }\r\n  path.icons09 {\r\n    fill: var(--icons09-enabled);\r\n  }\r\n}\r\n:host {\r\n  /**\r\n  * @prop --icon-size: Size of the icon (sets both width and height)\r\n  */\r\n  display: inline-flex;\r\n  svg {\r\n    width: var(--icon-size);\r\n    height: var(--icon-size);\r\n  }\r\n  line-height: 0;\r\n}\r\n","import { Component, Element, Prop, State, Watch, h } from \"@stencil/core\";\r\nimport { getSvgContent, iconContent } from \"./requests\";\r\n\r\n@Component({\r\n  tag: \"ch-icon\",\r\n  styleUrl: \"icon.scss\",\r\n  shadow: true,\r\n  assetsDirs: [\"ch-icon-assets\"]\r\n})\r\nexport class ChIcon {\r\n  private io?: IntersectionObserver;\r\n\r\n  @Element() element: HTMLChIconElement;\r\n\r\n  /** *******************************\r\n  PROPERTIES & STATE\r\n  *********************************/\r\n  /**\r\n   * The color of the icon.\r\n   *\r\n   */\r\n  @Prop() readonly color: Color;\r\n  /**\r\n   * If enabled, the icon will be loaded lazily when it's visible in the viewport.\r\n   */\r\n  @Prop() readonly lazy: boolean = false;\r\n\r\n  /**\r\n   * If enabled, the icon will display its inherent/natural color\r\n   */\r\n  @Prop({ reflect: true }) readonly autoColor: boolean = false;\r\n\r\n  /**\r\n   * The URL of the icon.\r\n   */\r\n  @Prop({ reflect: true }) readonly src: string = \"\";\r\n\r\n  /**\r\n   * The size of the icon. Possible values: regular, small.\r\n   */\r\n  @Prop() readonly size: Size = \"regular\";\r\n\r\n  @State() private isVisible = false;\r\n\r\n  @State() private svgContent?: string;\r\n\r\n  /** *******************************\r\n  METHODS\r\n  *********************************/\r\n\r\n  connectedCallback() {\r\n    // purposely do not return the promise here because loading\r\n    // the svg file should not hold up loading the app\r\n    // only load the svg if it's visible\r\n    this.waitUntilVisible(this.element, \"50px\", () => {\r\n      this.isVisible = true;\r\n      this.getIcon();\r\n    });\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (this.io !== undefined) {\r\n      this.io.disconnect();\r\n      this.io = undefined;\r\n    }\r\n  }\r\n\r\n  private waitUntilVisible(\r\n    el: HTMLElement,\r\n    rootMargin: string,\r\n    callback: () => void\r\n  ) {\r\n    if (\r\n      this.lazy &&\r\n      typeof window !== \"undefined\" &&\r\n      (window as any).IntersectionObserver\r\n    ) {\r\n      // TODO: FIX THIS\r\n      // eslint-disable-next-line no-multi-assign\r\n      const io = (this.io = new (window as any).IntersectionObserver(\r\n        (data: IntersectionObserverEntry[]) => {\r\n          if (data[0].isIntersecting) {\r\n            io.disconnect();\r\n            this.io = undefined;\r\n            callback();\r\n          }\r\n        },\r\n        { rootMargin }\r\n      ));\r\n\r\n      io.observe(el);\r\n    } else {\r\n      // browser doesn't support IntersectionObserver\r\n      // so just fallback to always show it\r\n      callback();\r\n    }\r\n  }\r\n\r\n  @Watch(\"src\")\r\n  private async getIcon() {\r\n    if (this.isVisible) {\r\n      if (this.src) {\r\n        if (iconContent.has(this.src)) {\r\n          this.svgContent = iconContent.get(this.src);\r\n        } else {\r\n          this.svgContent = await getSvgContent(this.src);\r\n        }\r\n      } else {\r\n        this.svgContent = \"\";\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return <div innerHTML={this.svgContent} />;\r\n  }\r\n}\r\n\r\nexport type Color =\r\n  | \"primary-enabled\"\r\n  | \"primary-active\"\r\n  | \"primary-hover\"\r\n  | \"onbackground\"\r\n  | \"negative\"\r\n  | \"disabled\"\r\n  | \"ondisabled\"\r\n  | \"error\"\r\n  | \"success\"\r\n  | \"warning\"\r\n  | \"alwaysblack\"\r\n  | \"auto\";\r\n\r\nexport type Size = \"regular\" | \"small\";\r\n"],"mappings":"gmDAAO,IAAMA,EAAc,IAAIC,IAC/B,IAAMC,EAAW,IAAID,I,SAELE,EAAcC,GAE5B,IAAIC,EAAUH,EAASI,IAAIF,GAE3B,IAAKC,EAAS,CAGZA,EAAUE,MAAMH,GAAKI,MAAK,SAAAC,GACxB,GAAIA,EAASC,GAAI,CACf,OAAOD,EAASE,OAAOH,MAAK,SAAAI,GAC1BZ,EAAYa,IAAIT,EAAKQ,GACrB,OAAOA,C,IAGXZ,EAAYa,IAAIT,EAAK,G,IAIvBF,EAASW,IAAIT,EAAKC,E,CAGpB,OAAOA,CACT,CCzBA,IAAMS,EAAU,uzBAChB,IAAAC,EAAeD,E,ICQFE,EAAMC,EAAA,qB,uDAgBgB,M,eAKsB,M,SAKP,G,UAKlB,U,eAED,M,2IAQ7BC,EAAAC,UAAAC,kBAAA,eAAAC,EAAAC,KAIEA,KAAKC,iBAAiBD,KAAKE,QAAS,QAAQ,WAC1CH,EAAKI,UAAY,KACjBJ,EAAKK,S,KAITR,EAAAC,UAAAQ,qBAAA,WACE,GAAIL,KAAKM,KAAOC,UAAW,CACzBP,KAAKM,GAAGE,aACRR,KAAKM,GAAKC,S,GAINX,EAAAC,UAAAI,iBAAA,SACNQ,EACAC,EACAC,GAHM,IAAAZ,EAAAC,KAKN,GACEA,KAAKY,aACEC,SAAW,aACjBA,OAAeC,qBAChB,CAGA,IAAMC,EAAMf,KAAKM,GAAK,IAAKO,OAAeC,sBACxC,SAACE,GACC,GAAIA,EAAK,GAAGC,eAAgB,CAC1BF,EAAGP,aACHT,EAAKO,GAAKC,UACVI,G,IAGJ,CAAED,WAAUA,IAGdK,EAAGG,QAAQT,E,KACN,CAGLE,G,GAKUf,EAAAC,UAAAO,QAAN,W,sHACFJ,KAAKG,UAAL,Y,IACEH,KAAKmB,IAAL,Y,IACEzC,EAAY0C,IAAIpB,KAAKmB,KAArB,YACFnB,KAAKV,WAAaZ,EAAYM,IAAIgB,KAAKmB,K,mBAEvCE,EAAArB,KAAkB,SAAMnB,EAAcmB,KAAKmB,M,OAA3CE,EAAK/B,WAAagC,EAAAC,O,oCAGpBvB,KAAKV,WAAa,G,mCAKxBM,EAAAC,UAAA2B,OAAA,WACE,OAAOC,EAAA,OAAAC,IAAA,2CAAKC,UAAW3B,KAAKV,Y,gPAzGb,I"}