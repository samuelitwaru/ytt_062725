{"version":3,"names":["intersectionObserverCss","ChIntersectionObserverStyle0","REGEX_TO_REPLACE_PERCENTAGE","REGEX_TO_TEST_DIP","REGEX_TO_TEST_PERCENTAGE","IntersectionObserverControl","defaultThreshold","observer","rootElement","rootMarginString","intersectionUpdate","checkValidDipValue","dipValue","test","this","convertDipToPxValue","checkValidPercentValue","percentValue","aux","replace","split","join","convertThresholdValueToNumber","threshold","Number","parseThreshold","finalThresholds","thresholdsToParse","forEach","thresholdValue","convertedNumber","push","setIntersectionObserver","options","root","rootMargin","IntersectionObserver","entries","emit","childElement","getChildElement","observe","element","firstElementChild","getComputedStyle","display","setIntersectionObserverOptionsFromProperties","document","getElementById","validatePosition","topMargin","leftMargin","bottomMargin","rightMargin","position","endsWith","componentDidLoad","disconnectedCallback","disconnect","undefined","render","h","key","name"],"sources":["src/components/intersection-observer/intersection-observer.scss?tag=ch-intersection-observer&encapsulation=shadow","src/components/intersection-observer/intersection-observer.tsx"],"sourcesContent":[":host {\r\n  display: contents;\r\n}\r\n","import {\r\n  Component,\r\n  h,\r\n  EventEmitter,\r\n  Event,\r\n  Element,\r\n  Prop\r\n} from \"@stencil/core\";\r\n\r\nconst REGEX_TO_REPLACE_PERCENTAGE = /%/g;\r\nconst REGEX_TO_TEST_DIP = /^\\d+(dip)?$/;\r\nconst REGEX_TO_TEST_PERCENTAGE = /^\\d+(%)?$/;\r\n\r\n@Component({\r\n  tag: \"ch-intersection-observer\",\r\n  styleUrl: \"intersection-observer.scss\",\r\n  shadow: true\r\n})\r\nexport class IntersectionObserverControl {\r\n  private defaultThreshold: Array<number> = [0];\r\n  private observer: IntersectionObserver;\r\n  private rootElement: HTMLElement;\r\n  private rootMarginString = \"\";\r\n\r\n  @Element() element: HTMLChIntersectionObserverElement;\r\n\r\n  /**\r\n   * Bottom margin around the root element\r\n   */\r\n  @Prop() readonly bottomMargin: string;\r\n\r\n  /**\r\n   * Left margin around the root element\r\n   */\r\n  @Prop() readonly leftMargin: string;\r\n\r\n  /**\r\n   * Right margin around the root element\r\n   */\r\n  @Prop() readonly rightMargin: string;\r\n\r\n  /**\r\n   *  Set the ID of the component that is used as the viewport, default is the browser.\r\n   */\r\n  @Prop() readonly root: string;\r\n\r\n  /**\r\n   * Numeric values representing percentages of the target element which are visible.\r\n   */\r\n  @Prop() readonly threshold: string;\r\n\r\n  /**\r\n   * Top margin around the root element\r\n   */\r\n  @Prop() readonly topMargin: string;\r\n\r\n  /**\r\n   * Emitted whenever the control reaches a threshold specified by the threshold property\r\n   * @param IntersectionObserverEntry Details of intersection object.\r\n   */\r\n  @Event() intersectionUpdate: EventEmitter<IntersectionObserverEntry>;\r\n\r\n  /**\r\n   * Used to check that the passed value is a valid device-independent-pixel (dip)\r\n   * value, and transform the dip to `px` value.\r\n   * @example\r\n   * Input: \"200dip\" Output: \"200px\"\r\n   * Input: \"50%\" Output: \"0px\"\r\n   * @param percentValue Represent the given dip value\r\n   * @returns When is a valid dip value returns the value converted to pixels. Otherwise returns \"0px\".\r\n   */\r\n  private checkValidDipValue(dipValue: string) {\r\n    return REGEX_TO_TEST_DIP.test(dipValue)\r\n      ? this.convertDipToPxValue(dipValue)\r\n      : \"0px\";\r\n  }\r\n\r\n  /**\r\n   * Used to check that the passed value is a valid percentage. @example: \"200%\"\r\n   * @param percentValue : Represent the given percentage value\r\n   * @returns When is a valid percentage value returns the value, otherwise returns \"0px\"\r\n   */\r\n  private checkValidPercentValue(percentValue: string) {\r\n    return REGEX_TO_TEST_PERCENTAGE.test(percentValue) ? percentValue : \"0px\";\r\n  }\r\n\r\n  /**\r\n   * @todo TODO: Simplify this implementation\r\n   * Transform the given dip value to pixels\r\n   * @param dipValue Represent the given dip value @example \"10dip\"\r\n   * @returns Returns the given value converted to px @example \"10px\"\r\n   */\r\n  private convertDipToPxValue(dipValue: string) {\r\n    const aux = dipValue.replace(\"dip\", \"px\");\r\n    return aux.split(\" \").join(\"\");\r\n  }\r\n\r\n  /**\r\n   * Convert the given percentages string representing a threshold value in decimal value\r\n   * @param threshold Threshold string representation @example: \"10%\"\r\n   * @returns Decimal value between 0 and 1 @example: 0.1\r\n   */\r\n  private convertThresholdValueToNumber(threshold: string) {\r\n    if (REGEX_TO_TEST_PERCENTAGE.test(threshold)) {\r\n      return Number(threshold.replace(REGEX_TO_REPLACE_PERCENTAGE, \"\")) / 100;\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Create a valid Javascript IntersectionObserver API threshold  options value\r\n   * @param threshold Threshold string representation @example: \"10%,30%,40%\"\r\n   * @returns Valid array of numbers in the range between 0 and 1 @example: [0.1, 0.3, 0.4]\r\n   */\r\n  private parseThreshold(threshold: string): number[] {\r\n    if (!threshold) {\r\n      return [0];\r\n    }\r\n\r\n    const finalThresholds: number[] = [];\r\n    const thresholdsToParse = threshold.split(\",\");\r\n\r\n    thresholdsToParse.forEach(thresholdValue => {\r\n      const convertedNumber =\r\n        this.convertThresholdValueToNumber(thresholdValue);\r\n\r\n      if (convertedNumber <= 1) {\r\n        finalThresholds.push(convertedNumber);\r\n      }\r\n    });\r\n    return finalThresholds;\r\n  }\r\n\r\n  /**\r\n   * Initialize intersection observer with its options and start observing\r\n   */\r\n  private setIntersectionObserver() {\r\n    const options: IntersectionObserverInit = {\r\n      root: this.rootElement,\r\n      rootMargin: this.rootMarginString,\r\n      threshold: this.defaultThreshold\r\n    };\r\n    this.observer = new IntersectionObserver(entries => {\r\n      this.intersectionUpdate.emit(entries[0]);\r\n    }, options);\r\n\r\n    const childElement = this.getChildElement();\r\n\r\n    if (childElement) {\r\n      this.observer.observe(childElement);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @returns The first child element that its display CSS property is different from `contents`\r\n   */\r\n  private getChildElement() {\r\n    let childElement = this.element.firstElementChild as HTMLElement;\r\n\r\n    while (\r\n      childElement &&\r\n      getComputedStyle(childElement).display === \"contents\"\r\n    ) {\r\n      childElement = childElement.firstElementChild as HTMLElement;\r\n    }\r\n    return childElement;\r\n  }\r\n\r\n  /**\r\n   * Transform the given initial intersection-observer component properties\r\n   * into Javascript IntersectionObserver API options valid values.\r\n   */\r\n  private setIntersectionObserverOptionsFromProperties() {\r\n    if (this.root) {\r\n      this.rootElement = document.getElementById(this.root);\r\n    }\r\n    this.rootMarginString = [\r\n      this.validatePosition(this.topMargin),\r\n      this.validatePosition(this.leftMargin),\r\n      this.validatePosition(this.bottomMargin),\r\n      this.validatePosition(this.rightMargin)\r\n    ].join(\" \");\r\n\r\n    this.defaultThreshold = this.parseThreshold(this.threshold);\r\n  }\r\n\r\n  /**\r\n   * Check that the given string value is a valid percentage or device\r\n   * independent pixel (dip) value.\r\n   * @param position Represent the given dip or px value\r\n   */\r\n  private validatePosition(position: string) {\r\n    if (position && position.endsWith(\"dip\")) {\r\n      return this.checkValidDipValue(position);\r\n    }\r\n    return this.checkValidPercentValue(position);\r\n  }\r\n\r\n  componentDidLoad() {\r\n    this.setIntersectionObserverOptionsFromProperties();\r\n    this.setIntersectionObserver();\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    if (this.observer) {\r\n      this.observer.disconnect();\r\n      this.observer = undefined;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return <slot name=\"content\" />;\r\n  }\r\n}\r\n"],"mappings":"yDAAA,MAAMA,EAA0B,0BAChC,MAAAC,EAAeD,ECQf,MAAME,EAA8B,KACpC,MAAMC,EAAoB,cAC1B,MAAMC,EAA2B,Y,MAOpBC,EAA2B,M,uOAC9BC,iBAAkC,CAAC,GACnCC,SACAC,YACAC,iBAAmB,G,6BAsClBC,mBAWD,kBAAAC,CAAmBC,GACzB,OAAOT,EAAkBU,KAAKD,GAC1BE,KAAKC,oBAAoBH,GACzB,K,CAQE,sBAAAI,CAAuBC,GAC7B,OAAOb,EAAyBS,KAAKI,GAAgBA,EAAe,K,CAS9D,mBAAAF,CAAoBH,GAC1B,MAAMM,EAAMN,EAASO,QAAQ,MAAO,MACpC,OAAOD,EAAIE,MAAM,KAAKC,KAAK,G,CAQrB,6BAAAC,CAA8BC,GACpC,GAAInB,EAAyBS,KAAKU,GAAY,CAC5C,OAAOC,OAAOD,EAAUJ,QAAQjB,EAA6B,KAAO,G,CAGtE,OAAO,C,CAQD,cAAAuB,CAAeF,GACrB,IAAKA,EAAW,CACd,MAAO,CAAC,E,CAGV,MAAMG,EAA4B,GAClC,MAAMC,EAAoBJ,EAAUH,MAAM,KAE1CO,EAAkBC,SAAQC,IACxB,MAAMC,EACJhB,KAAKQ,8BAA8BO,GAErC,GAAIC,GAAmB,EAAG,CACxBJ,EAAgBK,KAAKD,E,KAGzB,OAAOJ,C,CAMD,uBAAAM,GACN,MAAMC,EAAoC,CACxCC,KAAMpB,KAAKN,YACX2B,WAAYrB,KAAKL,iBACjBc,UAAWT,KAAKR,kBAElBQ,KAAKP,SAAW,IAAI6B,sBAAqBC,IACvCvB,KAAKJ,mBAAmB4B,KAAKD,EAAQ,GAAG,GACvCJ,GAEH,MAAMM,EAAezB,KAAK0B,kBAE1B,GAAID,EAAc,CAChBzB,KAAKP,SAASkC,QAAQF,E,EAOlB,eAAAC,GACN,IAAID,EAAezB,KAAK4B,QAAQC,kBAEhC,MACEJ,GACAK,iBAAiBL,GAAcM,UAAY,WAC3C,CACAN,EAAeA,EAAaI,iB,CAE9B,OAAOJ,C,CAOD,4CAAAO,GACN,GAAIhC,KAAKoB,KAAM,CACbpB,KAAKN,YAAcuC,SAASC,eAAelC,KAAKoB,K,CAElDpB,KAAKL,iBAAmB,CACtBK,KAAKmC,iBAAiBnC,KAAKoC,WAC3BpC,KAAKmC,iBAAiBnC,KAAKqC,YAC3BrC,KAAKmC,iBAAiBnC,KAAKsC,cAC3BtC,KAAKmC,iBAAiBnC,KAAKuC,cAC3BhC,KAAK,KAEPP,KAAKR,iBAAmBQ,KAAKW,eAAeX,KAAKS,U,CAQ3C,gBAAA0B,CAAiBK,GACvB,GAAIA,GAAYA,EAASC,SAAS,OAAQ,CACxC,OAAOzC,KAAKH,mBAAmB2C,E,CAEjC,OAAOxC,KAAKE,uBAAuBsC,E,CAGrC,gBAAAE,GACE1C,KAAKgC,+CACLhC,KAAKkB,yB,CAGP,oBAAAyB,GACE,GAAI3C,KAAKP,SAAU,CACjBO,KAAKP,SAASmD,aACd5C,KAAKP,SAAWoD,S,EAIpB,MAAAC,GACE,OAAOC,EAAA,QAAAC,IAAA,2CAAMC,KAAK,W"}